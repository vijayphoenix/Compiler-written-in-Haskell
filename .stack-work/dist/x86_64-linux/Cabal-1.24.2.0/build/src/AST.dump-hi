
==================== FINAL INTERFACE ====================
2019-04-25 17:53:03.428781 UTC

interface Haskull-0.1.0.0-BWrHz1hBGVfKvAfsCTzyaC:AST 8002
  interface hash: 362b18a09071a29b81e1f5fb430e8ec1
  ABI hash: 7766b3f629d0c491c3020be7c559cd28
  export-list hash: 5de5e88fd103c6732877d9f684527203
  orphan hash: 693e9af84d3dfcc71e640e005bdc5e2e
  flag hash: ab396f11155bd696ab63895436e6f1df
  sig of: Nothing
  used TH splices: False
  where
exports:
  AST.ArgList
  AST.Args
  AST.BinOpCall{AST.BinOpCall lhs op rhs}
  AST.Declaration{AST.ExternDecl AST.VarDecl efArgsList efName retT vName vType}
  AST.Expr{AST.BinOpCallStmt AST.DeclarationStmt AST.FuncCallStmt AST.LiteralStmt AST.Var}
  AST.Func{AST.Func argList body fname retType}
  AST.FuncCall{AST.FuncCall args callee}
  AST.Literal{AST.IntLiteral AST.StrLiteral}
  AST.Module{AST.Command AST.Method}
  AST.Name
  AST.Op{AST.Divide AST.Minus AST.Mul AST.Plus}
  AST.Type{AST.IntC AST.StringC}
  AST.VList
module dependencies:
package dependencies: base-4.9.1.0* ghc-prim-0.5.0.0
                      integer-gmp-1.0.0.1
orphans: base-4.9.1.0:GHC.Base base-4.9.1.0:GHC.Float
family instance modules: base-4.9.1.0:Control.Applicative
                         base-4.9.1.0:Data.Either base-4.9.1.0:Data.Functor.Const
                         base-4.9.1.0:Data.Monoid base-4.9.1.0:Data.Type.Equality
                         base-4.9.1.0:GHC.Generics base-4.9.1.0:GHC.IO.Exception
                         base-4.9.1.0:GHC.TypeLits
import  -/  base-4.9.1.0:GHC.Base c4231c43c07e46080a26bf94094c7aa1
import  -/  base-4.9.1.0:GHC.Show a027f5ac24879eaba752f44aa90fe511
import  -/  base-4.9.1.0:Prelude 22dd289b8469a8fa8dc81cab7b237771
import  -/  ghc-prim-0.5.0.0:GHC.Classes 0bdf3d057a415ec1b84a7b1994efbe47
import  -/  ghc-prim-0.5.0.0:GHC.Types 89f8de4f08018c9177c98d979eae0e45
import  -/  integer-gmp-1.0.0.1:GHC.Integer.Type 318df275d77dcdb18e0006d8d7870c2a
d50844ec2f0a6ba64eb2a2626294954b
  $fEqOp :: GHC.Classes.Eq AST.Op
  DFunId
  {- HasNoCafRefs, Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:. @ AST.Op AST.$fEqOp_$c== AST.$fEqOp_$c/= -}
d50844ec2f0a6ba64eb2a2626294954b
  $fEqOp_$c/= :: AST.Op -> AST.Op -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,1*U>,
     Unfolding: (\ (a :: AST.Op) (b :: AST.Op) ->
                 case a of wild {
                   AST.Plus
                   -> case b of wild1 {
                        DEFAULT -> GHC.Types.True AST.Plus -> GHC.Types.False }
                   AST.Minus
                   -> case b of wild1 {
                        DEFAULT -> GHC.Types.True AST.Minus -> GHC.Types.False }
                   AST.Mul
                   -> case b of wild1 {
                        DEFAULT -> GHC.Types.True AST.Mul -> GHC.Types.False }
                   AST.Divide
                   -> case b of wild1 {
                        DEFAULT -> GHC.Types.True AST.Divide -> GHC.Types.False } }) -}
d50844ec2f0a6ba64eb2a2626294954b
  $fEqOp_$c== :: AST.Op -> AST.Op -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,1*U>,
     Unfolding: (\ (ds :: AST.Op) (ds1 :: AST.Op) ->
                 case ds of wild {
                   AST.Plus
                   -> case ds1 of wild1 {
                        DEFAULT -> GHC.Types.False AST.Plus -> GHC.Types.True }
                   AST.Minus
                   -> case ds1 of wild1 {
                        DEFAULT -> GHC.Types.False AST.Minus -> GHC.Types.True }
                   AST.Mul
                   -> case ds1 of wild1 {
                        DEFAULT -> GHC.Types.False AST.Mul -> GHC.Types.True }
                   AST.Divide
                   -> case ds1 of wild1 {
                        DEFAULT -> GHC.Types.False AST.Divide -> GHC.Types.True } }) -}
d50844ec2f0a6ba64eb2a2626294954b
  $fOrdOp :: GHC.Classes.Ord AST.Op
  DFunId
  {- HasNoCafRefs, Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ AST.Op
                  AST.$fEqOp
                  AST.$fOrdOp_$ccompare
                  AST.$fOrdOp_$c<
                  AST.$fOrdOp_$c<=
                  AST.$fOrdOp_$c>
                  AST.$fOrdOp_$c>=
                  AST.$fOrdOp_$cmax
                  AST.$fOrdOp_$cmin -}
d50844ec2f0a6ba64eb2a2626294954b
  $fOrdOp_$c< :: AST.Op -> AST.Op -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,1*U>,
     Unfolding: (\ (a :: AST.Op) (b :: AST.Op) ->
                 case a of wild {
                   AST.Plus
                   -> case b of wild1 {
                        AST.Plus -> GHC.Types.False
                        AST.Minus -> GHC.Types.True
                        AST.Mul -> GHC.Types.True
                        AST.Divide -> GHC.Types.True }
                   AST.Minus
                   -> case b of wild1 {
                        DEFAULT -> GHC.Types.False
                        AST.Mul -> GHC.Types.True
                        AST.Divide -> GHC.Types.True }
                   AST.Mul
                   -> case b of wild1 {
                        DEFAULT -> GHC.Types.False AST.Divide -> GHC.Types.True }
                   AST.Divide -> case b of wild1 { DEFAULT -> GHC.Types.False } }) -}
d50844ec2f0a6ba64eb2a2626294954b
  $fOrdOp_$c<= :: AST.Op -> AST.Op -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,1*U>,
     Unfolding: (\ (a :: AST.Op) (b :: AST.Op) ->
                 case a of wild {
                   AST.Plus -> case b of wild1 { DEFAULT -> GHC.Types.True }
                   AST.Minus
                   -> case b of wild1 {
                        AST.Plus -> GHC.Types.False
                        AST.Minus -> GHC.Types.True
                        AST.Mul -> GHC.Types.True
                        AST.Divide -> GHC.Types.True }
                   AST.Mul
                   -> case b of wild1 {
                        DEFAULT -> GHC.Types.False
                        AST.Mul -> GHC.Types.True
                        AST.Divide -> GHC.Types.True }
                   AST.Divide
                   -> case b of wild1 {
                        DEFAULT -> GHC.Types.False AST.Divide -> GHC.Types.True } }) -}
d50844ec2f0a6ba64eb2a2626294954b
  $fOrdOp_$c> :: AST.Op -> AST.Op -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,1*U>,
     Unfolding: (\ (a :: AST.Op) (b :: AST.Op) ->
                 case a of wild {
                   AST.Plus -> case b of wild1 { DEFAULT -> GHC.Types.False }
                   AST.Minus
                   -> case b of wild1 {
                        AST.Plus -> GHC.Types.True
                        AST.Minus -> GHC.Types.False
                        AST.Mul -> GHC.Types.False
                        AST.Divide -> GHC.Types.False }
                   AST.Mul
                   -> case b of wild1 {
                        DEFAULT -> GHC.Types.True
                        AST.Mul -> GHC.Types.False
                        AST.Divide -> GHC.Types.False }
                   AST.Divide
                   -> case b of wild1 {
                        DEFAULT -> GHC.Types.True AST.Divide -> GHC.Types.False } }) -}
d50844ec2f0a6ba64eb2a2626294954b
  $fOrdOp_$c>= :: AST.Op -> AST.Op -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,1*U>,
     Unfolding: (\ (a :: AST.Op) (b :: AST.Op) ->
                 case a of wild {
                   AST.Plus
                   -> case b of wild1 {
                        AST.Plus -> GHC.Types.True
                        AST.Minus -> GHC.Types.False
                        AST.Mul -> GHC.Types.False
                        AST.Divide -> GHC.Types.False }
                   AST.Minus
                   -> case b of wild1 {
                        DEFAULT -> GHC.Types.True
                        AST.Mul -> GHC.Types.False
                        AST.Divide -> GHC.Types.False }
                   AST.Mul
                   -> case b of wild1 {
                        DEFAULT -> GHC.Types.True AST.Divide -> GHC.Types.False }
                   AST.Divide -> case b of wild1 { DEFAULT -> GHC.Types.True } }) -}
d50844ec2f0a6ba64eb2a2626294954b
  $fOrdOp_$ccompare :: AST.Op -> AST.Op -> GHC.Types.Ordering
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,1*U>,
     Unfolding: (\ (a :: AST.Op) (b :: AST.Op) ->
                 case a of wild {
                   AST.Plus
                   -> case b of wild1 {
                        AST.Plus -> GHC.Types.EQ
                        AST.Minus -> GHC.Types.LT
                        AST.Mul -> GHC.Types.LT
                        AST.Divide -> GHC.Types.LT }
                   AST.Minus
                   -> case b of wild1 {
                        AST.Plus -> GHC.Types.GT
                        AST.Minus -> GHC.Types.EQ
                        AST.Mul -> GHC.Types.LT
                        AST.Divide -> GHC.Types.LT }
                   AST.Mul
                   -> case b of wild1 {
                        DEFAULT -> GHC.Types.GT
                        AST.Mul -> GHC.Types.EQ
                        AST.Divide -> GHC.Types.LT }
                   AST.Divide
                   -> case b of wild1 {
                        DEFAULT -> GHC.Types.GT AST.Divide -> GHC.Types.EQ } }) -}
d50844ec2f0a6ba64eb2a2626294954b
  $fOrdOp_$cmax :: AST.Op -> AST.Op -> AST.Op
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,1*U>,
     Unfolding: (\ (x :: AST.Op) (y :: AST.Op) ->
                 case x of wild {
                   AST.Plus -> y
                   AST.Minus
                   -> case y of wild1 {
                        DEFAULT -> AST.Minus AST.Mul -> AST.Mul AST.Divide -> AST.Divide }
                   AST.Mul
                   -> case y of wild1 { DEFAULT -> AST.Mul AST.Divide -> AST.Divide }
                   AST.Divide -> case y of wild1 { DEFAULT -> AST.Divide } }) -}
d50844ec2f0a6ba64eb2a2626294954b
  $fOrdOp_$cmin :: AST.Op -> AST.Op -> AST.Op
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,1*U>,
     Unfolding: (\ (x :: AST.Op) (y :: AST.Op) ->
                 case x of wild {
                   AST.Plus -> case y of wild1 { DEFAULT -> AST.Plus }
                   AST.Minus
                   -> case y of wild1 {
                        AST.Plus -> AST.Plus
                        AST.Minus -> AST.Minus
                        AST.Mul -> AST.Minus
                        AST.Divide -> AST.Minus }
                   AST.Mul
                   -> case y of wild1 {
                        DEFAULT -> wild1 AST.Mul -> AST.Mul AST.Divide -> AST.Mul }
                   AST.Divide -> y }) -}
af81e849342728200b6b013e210a8251
  $fShowBinOpCall :: GHC.Show.Show AST.BinOpCall
  DFunId
  {- Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ AST.BinOpCall
                  AST.$fShowBinOpCall_$cshowsPrec
                  AST.$fShowBinOpCall_$cshow
                  AST.$fShowBinOpCall_$cshowList -}
af81e849342728200b6b013e210a8251
  $fShowBinOpCall1 :: AST.BinOpCall -> GHC.Show.ShowS
  {- Arity: 1,
     Unfolding: (\ (w :: AST.BinOpCall) ->
                 case w of ww { AST.BinOpCall ww1 ww2 ww3 ->
                 AST.$w$cshowsPrec 0# ww1 ww2 ww3 }) -}
af81e849342728200b6b013e210a8251
  $fShowBinOpCall_$cshow :: AST.BinOpCall -> GHC.Base.String
  {- Arity: 1, Strictness: <S,1*U(U,1*U,1*U)>,
     Unfolding: InlineRule (1, True, False)
                (\ (x :: AST.BinOpCall) ->
                 AST.$fShowBinOpCall_$cshowsPrec
                   GHC.Show.shows22
                   x
                   (GHC.Types.[] @ GHC.Types.Char)) -}
af81e849342728200b6b013e210a8251
  $fShowBinOpCall_$cshowList :: [AST.BinOpCall] -> GHC.Show.ShowS
  {- Arity: 2,
     Unfolding: (GHC.Show.showList__
                   @ AST.BinOpCall
                   AST.$fShowBinOpCall1) -}
af81e849342728200b6b013e210a8251
  $fShowBinOpCall_$cshowsPrec ::
    GHC.Types.Int -> AST.BinOpCall -> GHC.Show.ShowS
  {- Arity: 2, Strictness: <S(S),1*U(U)><S,1*U(U,1*U,1*U)>,
     Inline: INLINE[0],
     Unfolding: InlineRule (2, True, False)
                (\ (w :: GHC.Types.Int) (w1 :: AST.BinOpCall) ->
                 case w of ww { GHC.Types.I# ww1 ->
                 case w1 of ww2 { AST.BinOpCall ww3 ww4 ww5 ->
                 AST.$w$cshowsPrec ww1 ww3 ww4 ww5 } }) -}
33d432a2601c6e2c29dde14013901097
  $fShowDeclaration :: GHC.Show.Show AST.Declaration
  DFunId
  {- Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ AST.Declaration
                  AST.$fShowDeclaration_$cshowsPrec
                  AST.$fShowDeclaration_$cshow
                  AST.$fShowDeclaration_$cshowList -}
33d432a2601c6e2c29dde14013901097
  $fShowDeclaration1 :: AST.Declaration -> GHC.Show.ShowS
  {- Arity: 2,
     Unfolding: (\ (w :: AST.Declaration) (w1 :: GHC.Base.String) ->
                 AST.$w$cshowsPrec1 0# w w1) -}
33d432a2601c6e2c29dde14013901097
  $fShowDeclaration_$cshow :: AST.Declaration -> GHC.Base.String
  {- Arity: 1, Strictness: <S,1*U>,
     Unfolding: InlineRule (1, True, False)
                (\ (x :: AST.Declaration) ->
                 AST.$fShowDeclaration_$cshowsPrec
                   GHC.Show.shows22
                   x
                   (GHC.Types.[] @ GHC.Types.Char)) -}
33d432a2601c6e2c29dde14013901097
  $fShowDeclaration_$cshowList :: [AST.Declaration] -> GHC.Show.ShowS
  {- Arity: 2,
     Unfolding: (GHC.Show.showList__
                   @ AST.Declaration
                   AST.$fShowDeclaration1) -}
33d432a2601c6e2c29dde14013901097
  $fShowDeclaration_$cshowsPrec ::
    GHC.Types.Int -> AST.Declaration -> GHC.Show.ShowS
  {- Arity: 3, Strictness: <S(S),1*U(U)><S,1*U><L,U>,
     Inline: INLINE[0],
     Unfolding: InlineRule (3, True, False)
                (\ (w :: GHC.Types.Int)
                   (w1 :: AST.Declaration)
                   (w2 :: GHC.Base.String) ->
                 case w of ww { GHC.Types.I# ww1 ->
                 AST.$w$cshowsPrec1 ww1 w1 w2 }) -}
af81e849342728200b6b013e210a8251
  $fShowExpr :: GHC.Show.Show AST.Expr
  DFunId
  {- Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ AST.Expr
                  AST.$fShowExpr_$cshowsPrec
                  AST.$fShowExpr_$cshow
                  AST.$fShowExpr_$cshowList -}
af81e849342728200b6b013e210a8251
  $fShowExpr1 :: AST.Expr -> GHC.Show.ShowS
  {- Arity: 1,
     Unfolding: (\ (w :: AST.Expr) -> AST.$w$cshowsPrec2 0# w) -}
f61488b8ac29d31db35b8fe9048a1031
  $fShowExpr2 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "Var "#) -}
e930831b36214f7146e156c8171310b9
  $fShowExpr3 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "IntLiteral "#) -}
67b3a872b819d51a51c44e9c74af6820
  $fShowExpr4 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "StrLiteral "#) -}
06da88c52c8c71505053dbd32235d7df
  $fShowExpr5 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "LiteralStmt "#) -}
15deded150482f4412e424143b63b2eb
  $fShowExpr6 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "BinOpCallStmt "#) -}
e211fa1461815359e017e324757ca498
  $fShowExpr7 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "FuncCallStmt "#) -}
3f12ad544bde9014acdc1ba6fbec48cc
  $fShowExpr8 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "DeclarationStmt "#) -}
24218a66b218903e20bd53d8b1852c26
  $fShowExpr9 :: [GHC.Types.Char]
  {- HasNoCafRefs,
     Unfolding: (GHC.Types.:
                   @ GHC.Types.Char
                   GHC.Show.shows6
                   (GHC.Types.[] @ GHC.Types.Char)) -}
af81e849342728200b6b013e210a8251
  $fShowExpr_$cshow :: AST.Expr -> GHC.Base.String
  {- Arity: 1, Strictness: <S,1*U>,
     Unfolding: (\ (x :: AST.Expr) ->
                 case x of wild {
                   AST.DeclarationStmt b1
                   -> GHC.Base.++
                        @ GHC.Types.Char
                        AST.$fShowExpr8
                        (AST.$w$cshowsPrec1 11# b1 (GHC.Types.[] @ GHC.Types.Char))
                   AST.FuncCallStmt b1
                   -> GHC.Base.++
                        @ GHC.Types.Char
                        AST.$fShowExpr7
                        (case b1 of ww { AST.FuncCall ww1 ww2 ->
                         AST.$w$cshowsPrec4 11# ww1 ww2 (GHC.Types.[] @ GHC.Types.Char) })
                   AST.BinOpCallStmt b1
                   -> GHC.Base.++
                        @ GHC.Types.Char
                        AST.$fShowExpr6
                        (case b1 of ww { AST.BinOpCall ww1 ww2 ww3 ->
                         AST.$w$cshowsPrec
                           11#
                           ww1
                           ww2
                           ww3
                           (GHC.Types.[] @ GHC.Types.Char) })
                   AST.LiteralStmt b1
                   -> GHC.Base.++
                        @ GHC.Types.Char
                        AST.$fShowExpr5
                        (AST.$w$cshowsPrec3 11# b1 (GHC.Types.[] @ GHC.Types.Char))
                   AST.Var b1
                   -> GHC.Base.++
                        @ GHC.Types.Char
                        AST.$fShowExpr2
                        (GHC.Types.:
                           @ GHC.Types.Char
                           GHC.Show.shows6
                           (GHC.Show.showLitString b1 AST.$fShowExpr9)) }) -}
af81e849342728200b6b013e210a8251
  $fShowExpr_$cshowList :: [AST.Expr] -> GHC.Show.ShowS
  {- Arity: 2,
     Unfolding: (GHC.Show.showList__ @ AST.Expr AST.$fShowExpr1) -}
af81e849342728200b6b013e210a8251
  $fShowExpr_$cshowsPrec ::
    GHC.Types.Int -> AST.Expr -> GHC.Show.ShowS
  {- Arity: 2, Strictness: <S(S),1*U(U)><S,1*U>, Inline: INLINE[0],
     Unfolding: InlineRule (2, True, False)
                (\ (w :: GHC.Types.Int) (w1 :: AST.Expr) ->
                 case w of ww { GHC.Types.I# ww1 -> AST.$w$cshowsPrec2 ww1 w1 }) -}
2c82732cb23ac10238193b154494d0d4
  $fShowFunc :: GHC.Show.Show AST.Func
  DFunId
  {- Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ AST.Func
                  AST.$fShowFunc_$cshowsPrec
                  AST.$fShowFunc_$cshow
                  AST.$fShowFunc_$cshowList -}
2c82732cb23ac10238193b154494d0d4
  $fShowFunc1 :: AST.Func -> GHC.Show.ShowS
  {- Arity: 2,
     Unfolding: (\ (w :: AST.Func) (w1 :: GHC.Base.String) ->
                 case w of ww { AST.Func ww1 ww2 ww3 ww4 ->
                 AST.$w$cshowsPrec5 0# ww1 ww2 ww3 ww4 w1 }) -}
af81e849342728200b6b013e210a8251
  $fShowFuncCall :: GHC.Show.Show AST.FuncCall
  DFunId
  {- Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ AST.FuncCall
                  AST.$fShowFuncCall_$cshowsPrec
                  AST.$fShowFuncCall_$cshow
                  AST.$fShowFuncCall_$cshowList -}
af81e849342728200b6b013e210a8251
  $fShowFuncCall1 :: AST.FuncCall -> GHC.Show.ShowS
  {- Arity: 2,
     Unfolding: (\ (w :: AST.FuncCall) (w1 :: GHC.Base.String) ->
                 case w of ww { AST.FuncCall ww1 ww2 ->
                 AST.$w$cshowsPrec4 0# ww1 ww2 w1 }) -}
af81e849342728200b6b013e210a8251
  $fShowFuncCall_$cshow :: AST.FuncCall -> GHC.Base.String
  {- Arity: 1, Strictness: <S,1*U(1*U,1*U)>,
     Unfolding: InlineRule (1, True, False)
                (\ (x :: AST.FuncCall) ->
                 AST.$fShowFuncCall_$cshowsPrec
                   GHC.Show.shows22
                   x
                   (GHC.Types.[] @ GHC.Types.Char)) -}
af81e849342728200b6b013e210a8251
  $fShowFuncCall_$cshowList :: [AST.FuncCall] -> GHC.Show.ShowS
  {- Arity: 2,
     Unfolding: (GHC.Show.showList__
                   @ AST.FuncCall
                   AST.$fShowFuncCall1) -}
af81e849342728200b6b013e210a8251
  $fShowFuncCall_$cshowsPrec ::
    GHC.Types.Int -> AST.FuncCall -> GHC.Show.ShowS
  {- Arity: 3, Strictness: <S(S),1*U(U)><S,1*U(1*U,1*U)><L,U>,
     Inline: INLINE[0],
     Unfolding: InlineRule (3, True, False)
                (\ (w :: GHC.Types.Int)
                   (w1 :: AST.FuncCall)
                   (w2 :: GHC.Base.String) ->
                 case w of ww { GHC.Types.I# ww1 ->
                 case w1 of ww2 { AST.FuncCall ww3 ww4 ->
                 AST.$w$cshowsPrec4 ww1 ww3 ww4 w2 } }) -}
2c82732cb23ac10238193b154494d0d4
  $fShowFunc_$cshow :: AST.Func -> GHC.Base.String
  {- Arity: 1, Strictness: <S,1*U(1*U,1*U,1*U,1*U)>,
     Unfolding: InlineRule (1, True, False)
                (\ (x :: AST.Func) ->
                 AST.$fShowFunc_$cshowsPrec
                   GHC.Show.shows22
                   x
                   (GHC.Types.[] @ GHC.Types.Char)) -}
2c82732cb23ac10238193b154494d0d4
  $fShowFunc_$cshowList :: [AST.Func] -> GHC.Show.ShowS
  {- Arity: 2,
     Unfolding: (GHC.Show.showList__ @ AST.Func AST.$fShowFunc1) -}
2c82732cb23ac10238193b154494d0d4
  $fShowFunc_$cshowsPrec ::
    GHC.Types.Int -> AST.Func -> GHC.Show.ShowS
  {- Arity: 3,
     Strictness: <S(S),1*U(U)><S,1*U(1*U,1*U,1*U,1*U)><L,U>,
     Inline: INLINE[0],
     Unfolding: InlineRule (3, True, False)
                (\ (w :: GHC.Types.Int) (w1 :: AST.Func) (w2 :: GHC.Base.String) ->
                 case w of ww { GHC.Types.I# ww1 ->
                 case w1 of ww2 { AST.Func ww3 ww4 ww5 ww6 ->
                 AST.$w$cshowsPrec5 ww1 ww3 ww4 ww5 ww6 w2 } }) -}
b8bb7416e10a99296972bf2d0a577a40
  $fShowLiteral :: GHC.Show.Show AST.Literal
  DFunId
  {- Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ AST.Literal
                  AST.$fShowLiteral_$cshowsPrec
                  AST.$fShowLiteral_$cshow
                  AST.$fShowLiteral_$cshowList -}
b8bb7416e10a99296972bf2d0a577a40
  $fShowLiteral1 :: AST.Literal -> GHC.Show.ShowS
  {- Arity: 2,
     Unfolding: (\ (w :: AST.Literal) (w1 :: GHC.Base.String) ->
                 AST.$w$cshowsPrec3 0# w w1) -}
b8bb7416e10a99296972bf2d0a577a40
  $fShowLiteral_$cshow :: AST.Literal -> GHC.Base.String
  {- Arity: 1, Strictness: <S,1*U>,
     Unfolding: InlineRule (1, True, False)
                (\ (x :: AST.Literal) ->
                 AST.$fShowLiteral_$cshowsPrec
                   GHC.Show.shows22
                   x
                   (GHC.Types.[] @ GHC.Types.Char)) -}
b8bb7416e10a99296972bf2d0a577a40
  $fShowLiteral_$cshowList :: [AST.Literal] -> GHC.Show.ShowS
  {- Arity: 2,
     Unfolding: (GHC.Show.showList__
                   @ AST.Literal
                   AST.$fShowLiteral1) -}
b8bb7416e10a99296972bf2d0a577a40
  $fShowLiteral_$cshowsPrec ::
    GHC.Types.Int -> AST.Literal -> GHC.Show.ShowS
  {- Arity: 3, Strictness: <S(S),1*U(U)><S,1*U><L,U>,
     Inline: INLINE[0],
     Unfolding: InlineRule (3, True, False)
                (\ (w :: GHC.Types.Int)
                   (w1 :: AST.Literal)
                   (w2 :: GHC.Base.String) ->
                 case w of ww { GHC.Types.I# ww1 ->
                 AST.$w$cshowsPrec3 ww1 w1 w2 }) -}
355df018a652e749bb00172997f43e12
  $fShowModule :: GHC.Show.Show AST.Module
  DFunId
  {- Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ AST.Module
                  AST.$fShowModule_$cshowsPrec
                  AST.$fShowModule_$cshow
                  AST.$fShowModule_$cshowList -}
355df018a652e749bb00172997f43e12
  $fShowModule1 :: AST.Module -> GHC.Show.ShowS
  {- Arity: 1,
     Unfolding: (\ (w :: AST.Module) -> AST.$w$cshowsPrec6 0# w) -}
5c4e0523056d4f1058c519367937473f
  $fShowModule2 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "Method "#) -}
a4f47e45f2ec117f1e6994f1538e73c3
  $fShowModule3 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "Command "#) -}
c820a9e436ed7f35cd553c6e43240d10
  $fShowModule4 :: [GHC.Types.Char]
  {- HasNoCafRefs,
     Unfolding: (GHC.Types.:
                   @ GHC.Types.Char
                   GHC.Show.shows6
                   AST.$fShowModule5) -}
92d6729a5936c317029519af03a41939
  $fShowModule5 :: [GHC.Types.Char]
  {- HasNoCafRefs,
     Unfolding: (GHC.Types.:
                   @ GHC.Types.Char
                   GHC.Show.shows4
                   (GHC.Types.[] @ GHC.Types.Char)) -}
355df018a652e749bb00172997f43e12
  $fShowModule_$cshow :: AST.Module -> GHC.Base.String
  {- Arity: 1, Strictness: <S,1*U>,
     Unfolding: (\ (x :: AST.Module) ->
                 case x of wild {
                   AST.Command b1
                   -> GHC.Base.++
                        @ GHC.Types.Char
                        AST.$fShowModule3
                        (case b1 of wild1 {
                           AST.DeclarationStmt b2
                           -> GHC.Types.:
                                @ GHC.Types.Char
                                GHC.Show.shows7
                                (GHC.Base.++
                                   @ GHC.Types.Char
                                   AST.$fShowExpr8
                                   (AST.$w$cshowsPrec1 11# b2 AST.$fShowModule5))
                           AST.FuncCallStmt b2
                           -> GHC.Types.:
                                @ GHC.Types.Char
                                GHC.Show.shows7
                                (GHC.Base.++
                                   @ GHC.Types.Char
                                   AST.$fShowExpr7
                                   (case b2 of ww { AST.FuncCall ww1 ww2 ->
                                    AST.$w$cshowsPrec4 11# ww1 ww2 AST.$fShowModule5 }))
                           AST.BinOpCallStmt b2
                           -> GHC.Types.:
                                @ GHC.Types.Char
                                GHC.Show.shows7
                                (GHC.Base.++
                                   @ GHC.Types.Char
                                   AST.$fShowExpr6
                                   (case b2 of ww { AST.BinOpCall ww1 ww2 ww3 ->
                                    AST.$w$cshowsPrec 11# ww1 ww2 ww3 AST.$fShowModule5 }))
                           AST.LiteralStmt b2
                           -> GHC.Types.:
                                @ GHC.Types.Char
                                GHC.Show.shows7
                                (GHC.Base.++
                                   @ GHC.Types.Char
                                   AST.$fShowExpr5
                                   (AST.$w$cshowsPrec3 11# b2 AST.$fShowModule5))
                           AST.Var b2
                           -> GHC.Types.:
                                @ GHC.Types.Char
                                GHC.Show.shows7
                                (GHC.Base.++
                                   @ GHC.Types.Char
                                   AST.$fShowExpr2
                                   (GHC.Types.:
                                      @ GHC.Types.Char
                                      GHC.Show.shows6
                                      (GHC.Show.showLitString b2 AST.$fShowModule4))) })
                   AST.Method b1
                   -> GHC.Base.++
                        @ GHC.Types.Char
                        AST.$fShowModule2
                        (case b1 of ww { AST.Func ww1 ww2 ww3 ww4 ->
                         AST.$w$cshowsPrec5
                           11#
                           ww1
                           ww2
                           ww3
                           ww4
                           (GHC.Types.[] @ GHC.Types.Char) }) }) -}
355df018a652e749bb00172997f43e12
  $fShowModule_$cshowList :: [AST.Module] -> GHC.Show.ShowS
  {- Arity: 2,
     Unfolding: (GHC.Show.showList__ @ AST.Module AST.$fShowModule1) -}
355df018a652e749bb00172997f43e12
  $fShowModule_$cshowsPrec ::
    GHC.Types.Int -> AST.Module -> GHC.Show.ShowS
  {- Arity: 2, Strictness: <S(S),1*U(U)><S,1*U>, Inline: INLINE[0],
     Unfolding: InlineRule (2, True, False)
                (\ (w :: GHC.Types.Int) (w1 :: AST.Module) ->
                 case w of ww { GHC.Types.I# ww1 -> AST.$w$cshowsPrec6 ww1 w1 }) -}
d50844ec2f0a6ba64eb2a2626294954b
  $fShowOp :: GHC.Show.Show AST.Op
  DFunId
  {- Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ AST.Op
                  AST.$fShowOp_$cshowsPrec
                  AST.$fShowOp_$cshow
                  AST.$fShowOp_$cshowList -}
4a31a314c9cd0fe2f4d5bfa8273c55e0
  $fShowOp1 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "Divide"#) -}
4f66cc3162e895b43f05cb232e817b95
  $fShowOp2 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "Mul"#) -}
6891625723cb318491bb0ba9b9ae8c18
  $fShowOp3 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "Minus"#) -}
2af58b86e916ccefb295f4f49fa828d3
  $fShowOp4 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "Plus"#) -}
d50844ec2f0a6ba64eb2a2626294954b
  $fShowOp_$cshow :: AST.Op -> GHC.Base.String
  {- Arity: 1, Strictness: <S,1*U>,
     Unfolding: InlineRule (1, True, False)
                (\ (x :: AST.Op) ->
                 AST.$fShowOp_$cshowsPrec
                   GHC.Show.shows22
                   x
                   (GHC.Types.[] @ GHC.Types.Char)) -}
d50844ec2f0a6ba64eb2a2626294954b
  $fShowOp_$cshowList :: [AST.Op] -> GHC.Show.ShowS
  {- Arity: 2,
     Unfolding: (GHC.Show.showList__ @ AST.Op AST.$w$cshowsPrec7) -}
d50844ec2f0a6ba64eb2a2626294954b
  $fShowOp_$cshowsPrec :: GHC.Types.Int -> AST.Op -> GHC.Show.ShowS
  {- Arity: 3, Strictness: <L,A><S,1*U><L,1*U>, Inline: INLINE[0],
     Unfolding: InlineRule (3, True, True)
                (\ (w :: GHC.Types.Int) (w1 :: AST.Op) (w2 :: GHC.Base.String) ->
                 AST.$w$cshowsPrec7 w1 w2) -}
d08edfa29578fe246282f45c5f5b1a4f
  $fShowType :: GHC.Show.Show AST.Type
  DFunId
  {- Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ AST.Type
                  AST.$fShowType_$cshowsPrec
                  AST.$fShowType_$cshow
                  AST.$fShowType_$cshowList -}
d08edfa29578fe246282f45c5f5b1a4f
  $fShowType1 :: AST.Type -> GHC.Show.ShowS
  {- Arity: 2, Strictness: <S,1*U><L,1*U>,
     Unfolding: InlineRule (2, True, False)
                (\ (ds :: AST.Type) (eta :: GHC.Base.String) ->
                 case ds of wild {
                   AST.IntC
                   -> GHC.Base.augment
                        @ GHC.Types.Char
                        (\ @ b
                           (c :: GHC.Types.Char -> b -> b)[OneShot]
                           (n :: b)[OneShot] ->
                         GHC.Base.foldr @ GHC.Types.Char @ b c n AST.$fShowType3)
                        eta
                   AST.StringC
                   -> GHC.Base.augment
                        @ GHC.Types.Char
                        (\ @ b
                           (c :: GHC.Types.Char -> b -> b)[OneShot]
                           (n :: b)[OneShot] ->
                         GHC.Base.foldr @ GHC.Types.Char @ b c n AST.$fShowType2)
                        eta }) -}
cabeb6336128fb08221565b67c5512c4
  $fShowType2 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "StringC"#) -}
cdfdf2b9278170834d5e03065de60dac
  $fShowType3 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "IntC"#) -}
d08edfa29578fe246282f45c5f5b1a4f
  $fShowType_$cshow :: AST.Type -> GHC.Base.String
  {- Arity: 1, Strictness: <S,1*U>,
     Unfolding: InlineRule (1, True, False)
                (\ (x :: AST.Type) ->
                 case x of wild {
                   AST.IntC -> AST.$fShowType3 AST.StringC -> AST.$fShowType2 }) -}
d08edfa29578fe246282f45c5f5b1a4f
  $fShowType_$cshowList :: [AST.Type] -> GHC.Show.ShowS
  {- Arity: 2,
     Unfolding: (GHC.Show.showList__ @ AST.Type AST.$fShowType1) -}
d08edfa29578fe246282f45c5f5b1a4f
  $fShowType_$cshowsPrec ::
    GHC.Types.Int -> AST.Type -> GHC.Show.ShowS
  {- Arity: 3, Strictness: <L,A><S,1*U><L,1*U>,
     Unfolding: InlineRule (3, True, False)
                (\ (ds :: GHC.Types.Int)
                   (ds1 :: AST.Type)
                   (eta :: GHC.Base.String) ->
                 case ds1 of wild {
                   AST.IntC
                   -> GHC.Base.augment
                        @ GHC.Types.Char
                        (\ @ b
                           (c :: GHC.Types.Char -> b -> b)[OneShot]
                           (n :: b)[OneShot] ->
                         GHC.Base.foldr @ GHC.Types.Char @ b c n AST.$fShowType3)
                        eta
                   AST.StringC
                   -> GHC.Base.augment
                        @ GHC.Types.Char
                        (\ @ b
                           (c :: GHC.Types.Char -> b -> b)[OneShot]
                           (n :: b)[OneShot] ->
                         GHC.Base.foldr @ GHC.Types.Char @ b c n AST.$fShowType2)
                        eta }) -}
6c23c5e12f32257a89cc447af1d2e3f3
  $tc'BinOpCall :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   9111093824152357185##
                   14712591601265150104##
                   AST.$trModule
                   AST.$tc'BinOpCall1) -}
5549c65d603c0b8d91d30a370298c1b2
  $tc'BinOpCall1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS "'BinOpCall"#) -}
2468146cff8333e490ef1c61e883fa9e
  $tc'BinOpCallStmt :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   10841232274094629893##
                   12413967228827711818##
                   AST.$trModule
                   AST.$tc'BinOpCallStmt1) -}
87d54e825ef7c90a07f6f33d76871d5b
  $tc'BinOpCallStmt1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS "'BinOpCallStmt"#) -}
eeaee726a69706c21a7b39c4e61e269d
  $tc'Command :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   15852671738542343104##
                   11445675856013791238##
                   AST.$trModule
                   AST.$tc'Command1) -}
0a617cc9c70a924e18baa0069648cd62
  $tc'Command1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS "'Command"#) -}
92bcf5705b497c82815e18513ce45f2e
  $tc'DeclarationStmt :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   11246130418757833696##
                   6268551045479354168##
                   AST.$trModule
                   AST.$tc'DeclarationStmt1) -}
6b0d09629d1c6f6fd30eba4a7060f476
  $tc'DeclarationStmt1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS "'DeclarationStmt"#) -}
5ab9c0639747182e94d3421f6f69d4ee
  $tc'Divide :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   14200752492159304187##
                   16683356646424042013##
                   AST.$trModule
                   AST.$tc'Divide1) -}
bf45b734555b870177fe1ee33ff7aec1
  $tc'Divide1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS "'Divide"#) -}
e2aec8830e3cb76a4a43338832ef563c
  $tc'ExternDecl :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   5809444312816605735##
                   15343781389788828473##
                   AST.$trModule
                   AST.$tc'ExternDecl1) -}
3db19e57c7f1018de8bf92f3174d05d1
  $tc'ExternDecl1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS "'ExternDecl"#) -}
e7f8f6ba17d8bf1bb4b357bf6f9a3d7f
  $tc'Func :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   13100926332273642956##
                   14784800487681857607##
                   AST.$trModule
                   AST.$tc'Func1) -}
c8528cda0f572e9e5d11082e045f9192
  $tc'Func1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS "'Func"#) -}
bb08df0bcba3aac1451ee7ef0bf6c722
  $tc'FuncCall :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   16439101022390122738##
                   14415961479986343306##
                   AST.$trModule
                   AST.$tc'FuncCall1) -}
b9c1fa54ec818c7608aa4c7505451425
  $tc'FuncCall1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS "'FuncCall"#) -}
c9df78da95b2b3a6931c7e8ae8483929
  $tc'FuncCallStmt :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   5995172951780735898##
                   7549647943242969651##
                   AST.$trModule
                   AST.$tc'FuncCallStmt1) -}
c2f023b51574264f8c3ef6e56ce73366
  $tc'FuncCallStmt1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS "'FuncCallStmt"#) -}
806238bb7144a1b2e915eff6972a15de
  $tc'IntC :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   1977946977529170928##
                   333048735064702940##
                   AST.$trModule
                   AST.$tc'IntC1) -}
0063439a3105fa21db31a67811ce471d
  $tc'IntC1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS "'IntC"#) -}
dfb9562e9eac14e420bbab662676076e
  $tc'IntLiteral :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   8880741569478529878##
                   15999035927630791741##
                   AST.$trModule
                   AST.$tc'IntLiteral1) -}
bb9082ce48dcf1cc90f11988893beb5e
  $tc'IntLiteral1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS "'IntLiteral"#) -}
23023075393a5922a92f9850e165c7d1
  $tc'LiteralStmt :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   370159615411819220##
                   17831454595921908755##
                   AST.$trModule
                   AST.$tc'LiteralStmt1) -}
bdbf2a4e920eef83434a672ec17f2bae
  $tc'LiteralStmt1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS "'LiteralStmt"#) -}
35724bb9485c25cbd2974604380d49cb
  $tc'Method :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   15310807897757822144##
                   9591256946139840949##
                   AST.$trModule
                   AST.$tc'Method1) -}
dcfe27d6f8754011a9417d18f1274279
  $tc'Method1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS "'Method"#) -}
db918eb9b3f26b1589b1c6c54e926e94
  $tc'Minus :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   7229905863421551361##
                   13966564680581456121##
                   AST.$trModule
                   AST.$tc'Minus1) -}
ae6230fa290b5ccef893cc97d4c0db83
  $tc'Minus1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS "'Minus"#) -}
1f8bd9e20a4765d4f8b155e6e0c7a18e
  $tc'Mul :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   8397742044158085063##
                   8771513489872976709##
                   AST.$trModule
                   AST.$tc'Mul1) -}
77d9cc7a4b08c6ef48ae1d28c2a80512
  $tc'Mul1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS "'Mul"#) -}
75a2fa3e242697707b09746679c985d0
  $tc'Plus :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   10197795981649536361##
                   15642281628523637453##
                   AST.$trModule
                   AST.$tc'Plus1) -}
f7ee991888e1d03242fadd5b296ac7c9
  $tc'Plus1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS "'Plus"#) -}
7f2b665b120784a01e59b1f8cf936b95
  $tc'StrLiteral :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   10561872171518703139##
                   11720690440049382615##
                   AST.$trModule
                   AST.$tc'StrLiteral1) -}
ecdc623d2978a47b7c360739e2afa2aa
  $tc'StrLiteral1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS "'StrLiteral"#) -}
4a5a8f6faa825973a314c69aba3eaa69
  $tc'StringC :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   10994640782364945128##
                   14711237952023945993##
                   AST.$trModule
                   AST.$tc'StringC1) -}
466fc95d69a32baaab069e21d049f6a3
  $tc'StringC1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS "'StringC"#) -}
70506832b55fbdd2520e7a2d5fa4b897
  $tc'Var :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   2734214336352803458##
                   17491719764235147706##
                   AST.$trModule
                   AST.$tc'Var1) -}
cdc248ed789d96ede7d71080d220b2be
  $tc'Var1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS "'Var"#) -}
fa9cb96a3143d965b514d4e8fbf897a0
  $tc'VarDecl :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   16791476090816228085##
                   10277779294204785907##
                   AST.$trModule
                   AST.$tc'VarDecl1) -}
13f016c703f405bd71bd6c28b4722f81
  $tc'VarDecl1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS "'VarDecl"#) -}
b01e86b18a4cf2c5ba760b656d97fa1a
  $tcBinOpCall :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   13964145255608082440##
                   1430161091201353063##
                   AST.$trModule
                   AST.$tcBinOpCall1) -}
e1754ae4dbc42c2773e75a5cf37d7896
  $tcBinOpCall1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS "BinOpCall"#) -}
7de7a20f2f5553e1195fc3b30c1404de
  $tcDeclaration :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   15444332441202958344##
                   13170888219577988181##
                   AST.$trModule
                   AST.$tcDeclaration1) -}
da2ba579b18f68539d115c7c6466ba05
  $tcDeclaration1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS "Declaration"#) -}
d1197940312ecb59397b1f3d4c4b4080
  $tcExpr :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   5506522797614960203##
                   11337342189136803382##
                   AST.$trModule
                   AST.$tcExpr1) -}
c157c7508fed3f71f99a125e105868cf
  $tcExpr1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS "Expr"#) -}
2cfc999fcac82840bd8111a0a3410e4e
  $tcFunc :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   6730106532630521326##
                   224219281006855514##
                   AST.$trModule
                   AST.$tcFunc1) -}
302b911aaa06d61630208d803ad2e5a4
  $tcFunc1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS "Func"#) -}
5eb77ce0353dca4a037f979daaa798ff
  $tcFuncCall :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   10641481022789049405##
                   12761934584216246714##
                   AST.$trModule
                   AST.$tcFuncCall1) -}
46f6ec80a89763994730de5ea1e892cf
  $tcFuncCall1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS "FuncCall"#) -}
774c6074c898735eb0c2b783a4079801
  $tcLiteral :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   2494493805699845808##
                   16275078618600925045##
                   AST.$trModule
                   AST.$tcLiteral1) -}
aff79272e5a5fa1abe28950a517cf486
  $tcLiteral1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS "Literal"#) -}
b718034defa6fb169e4a5bcf37bec9e1
  $tcModule :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   6829190144921973474##
                   9721899862768502439##
                   AST.$trModule
                   AST.$tcModule1) -}
16cb94141ff8753de8d0d88313d1fdd3
  $tcModule1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS "Module"#) -}
ba049755ca8e5e8dfce86accf717ea27
  $tcOp :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   14276261146529622086##
                   10383660735455483038##
                   AST.$trModule
                   AST.$tcOp1) -}
fa00b8d5494f66e717f5bb50ec40fde2
  $tcOp1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS "Op"#) -}
ea6952a66b20f325cb2d0b660627529b
  $tcType :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   13959117156592968569##
                   7182200736783931326##
                   AST.$trModule
                   AST.$tcType1) -}
9161d9e017be0edcf47ef538549cd8b5
  $tcType1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS "Type"#) -}
ea2ab6a78c06a55606b21f4bff6cb1e7
  $trModule :: GHC.Types.Module
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.Module AST.$trModule2 AST.$trModule1) -}
dd4e81acbc239166c840b0678a3330fc
  $trModule1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS "AST"#) -}
825a6ea7330bfc570eac242a38b18104
  $trModule2 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS
                   "Haskull-0.1.0.0-BWrHz1hBGVfKvAfsCTzyaC"#) -}
af81e849342728200b6b013e210a8251
  $w$cshowsPrec ::
    GHC.Prim.Int# -> AST.Op -> AST.Expr -> AST.Expr -> GHC.Show.ShowS
  {- Arity: 4, Strictness: <S,U><L,U><L,1*U><L,1*U>, Inline: [0] -}
33d432a2601c6e2c29dde14013901097
  $w$cshowsPrec1 ::
    GHC.Prim.Int#
    -> AST.Declaration -> GHC.Base.String -> GHC.Base.String
  {- Arity: 3, Strictness: <S,U><S,1*U><L,U>, Inline: [0] -}
af81e849342728200b6b013e210a8251
  $w$cshowsPrec2 :: GHC.Prim.Int# -> AST.Expr -> GHC.Show.ShowS
  {- Arity: 2, Strictness: <S,U><S,1*U>, Inline: [0],
     Unfolding: (\ (ww :: GHC.Prim.Int#) (w :: AST.Expr) ->
                 case w of wild {
                   AST.DeclarationStmt b1
                   -> case GHC.Prim.tagToEnum#
                             @ GHC.Types.Bool
                             (GHC.Prim.>=# ww 11#) of wild1 {
                        GHC.Types.False
                        -> \ (x :: GHC.Base.String) ->
                           GHC.Base.++
                             @ GHC.Types.Char
                             AST.$fShowExpr8
                             (AST.$w$cshowsPrec1 11# b1 x)
                        GHC.Types.True
                        -> \ (x :: GHC.Base.String) ->
                           GHC.Types.:
                             @ GHC.Types.Char
                             GHC.Show.shows7
                             (GHC.Base.++
                                @ GHC.Types.Char
                                AST.$fShowExpr8
                                (AST.$w$cshowsPrec1
                                   11#
                                   b1
                                   (GHC.Types.: @ GHC.Types.Char GHC.Show.shows4 x))) }
                   AST.FuncCallStmt b1
                   -> case GHC.Prim.tagToEnum#
                             @ GHC.Types.Bool
                             (GHC.Prim.>=# ww 11#) of wild1 {
                        GHC.Types.False
                        -> \ (x :: GHC.Base.String) ->
                           GHC.Base.++
                             @ GHC.Types.Char
                             AST.$fShowExpr7
                             (case b1 of ww1 { AST.FuncCall ww2 ww3 ->
                              AST.$w$cshowsPrec4 11# ww2 ww3 x })
                        GHC.Types.True
                        -> \ (x :: GHC.Base.String) ->
                           GHC.Types.:
                             @ GHC.Types.Char
                             GHC.Show.shows7
                             (GHC.Base.++
                                @ GHC.Types.Char
                                AST.$fShowExpr7
                                (case b1 of ww1 { AST.FuncCall ww2 ww3 ->
                                 AST.$w$cshowsPrec4
                                   11#
                                   ww2
                                   ww3
                                   (GHC.Types.: @ GHC.Types.Char GHC.Show.shows4 x) })) }
                   AST.BinOpCallStmt b1
                   -> let {
                        g :: GHC.Base.String -> GHC.Base.String
                        = case b1 of ww1 { AST.BinOpCall ww2 ww3 ww4 ->
                          AST.$w$cshowsPrec 11# ww2 ww3 ww4 }
                      } in
                      case GHC.Prim.tagToEnum#
                             @ GHC.Types.Bool
                             (GHC.Prim.>=# ww 11#) of wild1 {
                        GHC.Types.False
                        -> \ (x :: GHC.Base.String) ->
                           GHC.Base.++ @ GHC.Types.Char AST.$fShowExpr6 (g x)
                        GHC.Types.True
                        -> \ (x :: GHC.Base.String) ->
                           GHC.Types.:
                             @ GHC.Types.Char
                             GHC.Show.shows7
                             (GHC.Base.++
                                @ GHC.Types.Char
                                AST.$fShowExpr6
                                (g (GHC.Types.: @ GHC.Types.Char GHC.Show.shows4 x))) }
                   AST.LiteralStmt b1
                   -> case GHC.Prim.tagToEnum#
                             @ GHC.Types.Bool
                             (GHC.Prim.>=# ww 11#) of wild1 {
                        GHC.Types.False
                        -> \ (x :: GHC.Base.String) ->
                           GHC.Base.++
                             @ GHC.Types.Char
                             AST.$fShowExpr5
                             (AST.$w$cshowsPrec3 11# b1 x)
                        GHC.Types.True
                        -> \ (x :: GHC.Base.String) ->
                           GHC.Types.:
                             @ GHC.Types.Char
                             GHC.Show.shows7
                             (GHC.Base.++
                                @ GHC.Types.Char
                                AST.$fShowExpr5
                                (AST.$w$cshowsPrec3
                                   11#
                                   b1
                                   (GHC.Types.: @ GHC.Types.Char GHC.Show.shows4 x))) }
                   AST.Var b1
                   -> case GHC.Prim.tagToEnum#
                             @ GHC.Types.Bool
                             (GHC.Prim.>=# ww 11#) of wild1 {
                        GHC.Types.False
                        -> \ (x :: GHC.Base.String) ->
                           GHC.Base.++
                             @ GHC.Types.Char
                             AST.$fShowExpr2
                             (GHC.Types.:
                                @ GHC.Types.Char
                                GHC.Show.shows6
                                (GHC.Show.showLitString
                                   b1
                                   (GHC.Types.: @ GHC.Types.Char GHC.Show.shows6 x)))
                        GHC.Types.True
                        -> \ (x :: GHC.Base.String) ->
                           GHC.Types.:
                             @ GHC.Types.Char
                             GHC.Show.shows7
                             (GHC.Base.++
                                @ GHC.Types.Char
                                AST.$fShowExpr2
                                (GHC.Types.:
                                   @ GHC.Types.Char
                                   GHC.Show.shows6
                                   (GHC.Show.showLitString
                                      b1
                                      (GHC.Types.:
                                         @ GHC.Types.Char
                                         GHC.Show.shows6
                                         (GHC.Types.:
                                            @ GHC.Types.Char
                                            GHC.Show.shows4
                                            x))))) } }) -}
b8bb7416e10a99296972bf2d0a577a40
  $w$cshowsPrec3 ::
    GHC.Prim.Int# -> AST.Literal -> GHC.Base.String -> GHC.Base.String
  {- Arity: 3, Strictness: <S,U><S,1*U><L,U>, Inline: [0],
     Unfolding: (\ (ww :: GHC.Prim.Int#)
                   (w :: AST.Literal)
                   (w1 :: GHC.Base.String) ->
                 case w of wild {
                   AST.StrLiteral b1
                   -> case GHC.Prim.tagToEnum#
                             @ GHC.Types.Bool
                             (GHC.Prim.>=# ww 11#) of wild1 {
                        GHC.Types.False
                        -> GHC.Base.++
                             @ GHC.Types.Char
                             AST.$fShowExpr4
                             (GHC.Types.:
                                @ GHC.Types.Char
                                GHC.Show.shows6
                                (GHC.Show.showLitString
                                   b1
                                   (GHC.Types.: @ GHC.Types.Char GHC.Show.shows6 w1)))
                        GHC.Types.True
                        -> GHC.Types.:
                             @ GHC.Types.Char
                             GHC.Show.shows7
                             (GHC.Base.++
                                @ GHC.Types.Char
                                AST.$fShowExpr4
                                (GHC.Types.:
                                   @ GHC.Types.Char
                                   GHC.Show.shows6
                                   (GHC.Show.showLitString
                                      b1
                                      (GHC.Types.:
                                         @ GHC.Types.Char
                                         GHC.Show.shows6
                                         (GHC.Types.: @ GHC.Types.Char GHC.Show.shows4 w1))))) }
                   AST.IntLiteral b1
                   -> case GHC.Prim.tagToEnum#
                             @ GHC.Types.Bool
                             (GHC.Prim.>=# ww 11#) of wild1 {
                        GHC.Types.False
                        -> GHC.Base.++
                             @ GHC.Types.Char
                             AST.$fShowExpr3
                             (case GHC.Show.$w$cshowsPrec1 11# b1 w1 of ww2 { (#,#) ww3 ww4 ->
                              GHC.Types.: @ GHC.Types.Char ww3 ww4 })
                        GHC.Types.True
                        -> GHC.Types.:
                             @ GHC.Types.Char
                             GHC.Show.shows7
                             (GHC.Base.++
                                @ GHC.Types.Char
                                AST.$fShowExpr3
                                (case GHC.Show.$w$cshowsPrec1
                                        11#
                                        b1
                                        (GHC.Types.:
                                           @ GHC.Types.Char
                                           GHC.Show.shows4
                                           w1) of ww2 { (#,#) ww3 ww4 ->
                                 GHC.Types.: @ GHC.Types.Char ww3 ww4 })) } }) -}
af81e849342728200b6b013e210a8251
  $w$cshowsPrec4 ::
    GHC.Prim.Int#
    -> AST.Name -> AST.Args -> GHC.Base.String -> GHC.Base.String
  {- Arity: 4, Strictness: <S,U><L,1*U><L,1*U><L,U>, Inline: [0] -}
13a3e9f11621e85ba956997b7805f03a
  $w$cshowsPrec5 ::
    GHC.Prim.Int#
    -> AST.Name
    -> AST.ArgList
    -> AST.Type
    -> [AST.Expr]
    -> GHC.Base.String
    -> GHC.Base.String
  {- Arity: 6, Strictness: <S,U><L,1*U><L,1*U><L,1*U><L,1*U><L,U>,
     Inline: [0] -}
355df018a652e749bb00172997f43e12
  $w$cshowsPrec6 :: GHC.Prim.Int# -> AST.Module -> GHC.Show.ShowS
  {- Arity: 2, Strictness: <S,U><S,1*U>, Inline: [0],
     Unfolding: (\ (ww :: GHC.Prim.Int#) (w :: AST.Module) ->
                 case w of wild {
                   AST.Command b1
                   -> let {
                        g :: GHC.Base.String -> GHC.Base.String = AST.$w$cshowsPrec2 11# b1
                      } in
                      case GHC.Prim.tagToEnum#
                             @ GHC.Types.Bool
                             (GHC.Prim.>=# ww 11#) of wild1 {
                        GHC.Types.False
                        -> \ (x :: GHC.Base.String) ->
                           GHC.Base.++ @ GHC.Types.Char AST.$fShowModule3 (g x)
                        GHC.Types.True
                        -> \ (x :: GHC.Base.String) ->
                           GHC.Types.:
                             @ GHC.Types.Char
                             GHC.Show.shows7
                             (GHC.Base.++
                                @ GHC.Types.Char
                                AST.$fShowModule3
                                (g (GHC.Types.: @ GHC.Types.Char GHC.Show.shows4 x))) }
                   AST.Method b1
                   -> case GHC.Prim.tagToEnum#
                             @ GHC.Types.Bool
                             (GHC.Prim.>=# ww 11#) of wild1 {
                        GHC.Types.False
                        -> \ (x :: GHC.Base.String) ->
                           GHC.Base.++
                             @ GHC.Types.Char
                             AST.$fShowModule2
                             (case b1 of ww1 { AST.Func ww2 ww3 ww4 ww5 ->
                              AST.$w$cshowsPrec5 11# ww2 ww3 ww4 ww5 x })
                        GHC.Types.True
                        -> \ (x :: GHC.Base.String) ->
                           GHC.Types.:
                             @ GHC.Types.Char
                             GHC.Show.shows7
                             (GHC.Base.++
                                @ GHC.Types.Char
                                AST.$fShowModule2
                                (case b1 of ww1 { AST.Func ww2 ww3 ww4 ww5 ->
                                 AST.$w$cshowsPrec5
                                   11#
                                   ww2
                                   ww3
                                   ww4
                                   ww5
                                   (GHC.Types.: @ GHC.Types.Char GHC.Show.shows4 x) })) } }) -}
d50844ec2f0a6ba64eb2a2626294954b
  $w$cshowsPrec7 :: AST.Op -> GHC.Base.String -> GHC.Base.String
  {- Arity: 2, Strictness: <S,1*U><L,1*U>, Inline: [0],
     Unfolding: (\ (w :: AST.Op) (w1 :: GHC.Base.String) ->
                 case w of wild {
                   AST.Plus -> GHC.Base.++ @ GHC.Types.Char AST.$fShowOp4 w1
                   AST.Minus -> GHC.Base.++ @ GHC.Types.Char AST.$fShowOp3 w1
                   AST.Mul -> GHC.Base.++ @ GHC.Types.Char AST.$fShowOp2 w1
                   AST.Divide -> GHC.Base.++ @ GHC.Types.Char AST.$fShowOp1 w1 }) -}
938a528b4930e229d3ec647e96cab48f
  type ArgList = [(AST.Type, AST.Name)]
af81e849342728200b6b013e210a8251
  type Args = [AST.Expr]
af81e849342728200b6b013e210a8251
  data BinOpCall
    = BinOpCall {op :: AST.Op, lhs :: AST.Expr, rhs :: AST.Expr}
33d432a2601c6e2c29dde14013901097
  data Declaration
    = ExternDecl {efName :: AST.Name,
                  efArgsList :: AST.ArgList,
                  retT :: AST.Type}
    | VarDecl {vType :: AST.Type, vName :: AST.VList}
af81e849342728200b6b013e210a8251
  data Expr
    = DeclarationStmt AST.Declaration
    | FuncCallStmt AST.FuncCall
    | BinOpCallStmt AST.BinOpCall
    | LiteralStmt AST.Literal
    | Var AST.Name
2c82732cb23ac10238193b154494d0d4
  data Func
    = Func {fname :: AST.Name,
            argList :: AST.ArgList,
            retType :: AST.Type,
            body :: [AST.Expr]}
af81e849342728200b6b013e210a8251
  data FuncCall = FuncCall {callee :: AST.Name, args :: AST.Args}
b8bb7416e10a99296972bf2d0a577a40
  data Literal
    = StrLiteral GHC.Base.String | IntLiteral GHC.Integer.Type.Integer
355df018a652e749bb00172997f43e12
  data Module = Command AST.Expr | Method AST.Func
1259c2391d401e2b054e422bbb9873f0
  type Name = GHC.Base.String
d50844ec2f0a6ba64eb2a2626294954b
  data Op = Plus | Minus | Mul | Divide
d08edfa29578fe246282f45c5f5b1a4f
  data Type = IntC | StringC
daf6629269ae46fdb5a48a6af1953b29
  type VList = [AST.Name]
0c9ae1f286432efe1e0de6156f241282
  argList :: AST.Func -> AST.ArgList
  RecSel Left AST.Func
  {- Arity: 1, HasNoCafRefs, Strictness: <S(LSLL),1*U(A,1*U,A,A)>,
     Unfolding: InlineRule (1, True, False)
                (\ (ds :: AST.Func) ->
                 case ds of wild { AST.Func ds1 ds2 ds3 ds4 -> ds2 }) -}
3dccc295da99782ae7f300bd2e36137a
  args :: AST.FuncCall -> AST.Args
  RecSel Left AST.FuncCall
  {- Arity: 1, HasNoCafRefs, Strictness: <S(LS),1*U(A,1*U)>,
     Unfolding: InlineRule (1, True, False)
                (\ (ds :: AST.FuncCall) ->
                 case ds of wild { AST.FuncCall ds1 ds2 -> ds2 }) -}
301c27309373e79dd4090a7915c39e5c
  body :: AST.Func -> [AST.Expr]
  RecSel Left AST.Func
  {- Arity: 1, HasNoCafRefs, Strictness: <S(LLLS),1*U(A,A,A,1*U)>,
     Unfolding: InlineRule (1, True, False)
                (\ (ds :: AST.Func) ->
                 case ds of wild { AST.Func ds1 ds2 ds3 ds4 -> ds4 }) -}
5c2f687cd9f408c567e47e1c1595dec5
  callee :: AST.FuncCall -> AST.Name
  RecSel Left AST.FuncCall
  {- Arity: 1, HasNoCafRefs, Strictness: <S(SL),1*U(1*U,A)>,
     Unfolding: InlineRule (1, True, False)
                (\ (ds :: AST.FuncCall) ->
                 case ds of wild { AST.FuncCall ds1 ds2 -> ds1 }) -}
e68025fa8e7db30e7da104c58aedfa34
  efArgsList :: AST.Declaration -> AST.ArgList
  RecSel Left AST.Declaration
  {- Arity: 1, Strictness: <S,1*U>,
     Unfolding: InlineRule (1, True, False)
                (\ (ds :: AST.Declaration) ->
                 case ds of wild {
                   AST.ExternDecl ds1 ds2 ds3 -> ds2
                   AST.VarDecl ipv ipv1 -> AST.efArgsList1 }) -}
bb1a68f7900a9cbb9ba4d4b441bf9846
  efArgsList1 :: AST.ArgList
  {- Strictness: x -}
23d99c40a750a7f0fbca020f6a81e0fe
  efName :: AST.Declaration -> AST.Name
  RecSel Left AST.Declaration
  {- Arity: 1, Strictness: <S,1*U>,
     Unfolding: InlineRule (1, True, False)
                (\ (ds :: AST.Declaration) ->
                 case ds of wild {
                   AST.ExternDecl ds1 ds2 ds3 -> ds1
                   AST.VarDecl ipv ipv1 -> AST.efName1 }) -}
0f3b9c89a55cc9a225d04d7e65bd71eb
  efName1 :: AST.Name
  {- Strictness: x -}
edf506dde7896eb84d3a187e519ea653
  fname :: AST.Func -> AST.Name
  RecSel Left AST.Func
  {- Arity: 1, HasNoCafRefs, Strictness: <S(SLLL),1*U(1*U,A,A,A)>,
     Unfolding: InlineRule (1, True, False)
                (\ (ds :: AST.Func) ->
                 case ds of wild { AST.Func ds1 ds2 ds3 ds4 -> ds1 }) -}
c9a73511cc1e4db6a141f0eea9a06988
  lhs :: AST.BinOpCall -> AST.Expr
  RecSel Left AST.BinOpCall
  {- Arity: 1, HasNoCafRefs, Strictness: <S(LSL),1*U(A,1*U,A)>,
     Unfolding: InlineRule (1, True, False)
                (\ (ds :: AST.BinOpCall) ->
                 case ds of wild { AST.BinOpCall ds1 ds2 ds3 -> ds2 }) -}
469a821fefb37b24448851b58a7b74fd
  op :: AST.BinOpCall -> AST.Op
  RecSel Left AST.BinOpCall
  {- Arity: 1, HasNoCafRefs, Strictness: <S(SLL),1*U(1*U,A,A)>,
     Unfolding: InlineRule (1, True, False)
                (\ (ds :: AST.BinOpCall) ->
                 case ds of wild { AST.BinOpCall ds1 ds2 ds3 -> ds1 }) -}
b6f109dc27078c38a3d12e9fa7bdba9f
  retT :: AST.Declaration -> AST.Type
  RecSel Left AST.Declaration
  {- Arity: 1, Strictness: <S,1*U>,
     Unfolding: InlineRule (1, True, False)
                (\ (ds :: AST.Declaration) ->
                 case ds of wild {
                   AST.ExternDecl ds1 ds2 ds3 -> ds3
                   AST.VarDecl ipv ipv1 -> AST.retT1 }) -}
3b7ac6eeeb711621560801d1ca67ca9d
  retT1 :: AST.Type
  {- Strictness: x -}
264c157d873ec35326407e44d4d82949
  retType :: AST.Func -> AST.Type
  RecSel Left AST.Func
  {- Arity: 1, HasNoCafRefs, Strictness: <S(LLSL),1*U(A,A,1*U,A)>,
     Unfolding: InlineRule (1, True, False)
                (\ (ds :: AST.Func) ->
                 case ds of wild { AST.Func ds1 ds2 ds3 ds4 -> ds3 }) -}
0839c8c3165eeb6f7a83eb62e5df3e73
  rhs :: AST.BinOpCall -> AST.Expr
  RecSel Left AST.BinOpCall
  {- Arity: 1, HasNoCafRefs, Strictness: <S(LLS),1*U(A,A,1*U)>,
     Unfolding: InlineRule (1, True, False)
                (\ (ds :: AST.BinOpCall) ->
                 case ds of wild { AST.BinOpCall ds1 ds2 ds3 -> ds3 }) -}
561faccd475184eaeb702e48e533fd61
  vName :: AST.Declaration -> AST.VList
  RecSel Left AST.Declaration
  {- Arity: 1, Strictness: <S,1*U>,
     Unfolding: InlineRule (1, True, False)
                (\ (ds :: AST.Declaration) ->
                 case ds of wild {
                   AST.ExternDecl ipv ipv1 ipv2 -> AST.vName1
                   AST.VarDecl ds1 ds2 -> ds2 }) -}
7016d17858639ecb9d84194fcc065d6d
  vName1 :: AST.VList
  {- Strictness: x -}
9bac1c3441d69a848a5764238ea3f0a9
  vType :: AST.Declaration -> AST.Type
  RecSel Left AST.Declaration
  {- Arity: 1, Strictness: <S,1*U>,
     Unfolding: InlineRule (1, True, False)
                (\ (ds :: AST.Declaration) ->
                 case ds of wild {
                   AST.ExternDecl ipv ipv1 ipv2 -> AST.vType1
                   AST.VarDecl ds1 ds2 -> ds1 }) -}
674bb9b083977929ec7984418f05d579
  vType1 :: AST.Type
  {- Strictness: x -}
instance [safe] GHC.Classes.Eq [AST.Op] = AST.$fEqOp
instance [safe] GHC.Classes.Ord [AST.Op] = AST.$fOrdOp
instance [safe] GHC.Show.Show [AST.BinOpCall] = AST.$fShowBinOpCall
instance [safe] GHC.Show.Show [AST.Declaration]
  = AST.$fShowDeclaration
instance [safe] GHC.Show.Show [AST.Expr] = AST.$fShowExpr
instance [safe] GHC.Show.Show [AST.Func] = AST.$fShowFunc
instance [safe] GHC.Show.Show [AST.FuncCall] = AST.$fShowFuncCall
instance [safe] GHC.Show.Show [AST.Literal] = AST.$fShowLiteral
instance [safe] GHC.Show.Show [AST.Module] = AST.$fShowModule
instance [safe] GHC.Show.Show [AST.Op] = AST.$fShowOp
instance [safe] GHC.Show.Show [AST.Type] = AST.$fShowType
vectorised variables:
vectorised tycons:
vectorised reused tycons:
parallel variables:
parallel tycons:
trusted: safe
require own pkg trusted: False

