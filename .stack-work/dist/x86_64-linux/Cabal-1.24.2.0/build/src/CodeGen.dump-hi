
==================== FINAL INTERFACE ====================
2019-04-25 17:53:04.350487 UTC

interface Haskull-0.1.0.0-BWrHz1hBGVfKvAfsCTzyaC:CodeGen 8002
  interface hash: 9c4914756d8b4a92d36576bdf81f8112
  ABI hash: 23d9a5f33de319117cec4ca4f04a712b
  export-list hash: 3b43bfdc425c7d4b9de05bd0f34b7d2b
  orphan hash: 6ae230138444d243bee26a17cafaf9f9
  flag hash: 73e49978065ea61a006c0e9737b583d4
  sig of: Nothing
  used TH splices: False
  where
exports:
  CodeGen.addDef
  CodeGen.alloca
  CodeGen.assign
  CodeGen.createBlocks
  CodeGen.current
  CodeGen.define
  CodeGen.emptyBlock
  CodeGen.emptyCodegen
  CodeGen.entryBlockName
  CodeGen.execCodegen
  CodeGen.fresh
  CodeGen.getArgList
  CodeGen.getDef
  CodeGen.getExtern
  CodeGen.getName
  CodeGen.getType
  CodeGen.getvar
  CodeGen.instr
  CodeGen.intL
  CodeGen.load
  CodeGen.local
  CodeGen.makeBlock
  CodeGen.modifyBlock
  CodeGen.ret
  CodeGen.runLLVM
  CodeGen.setBlock
  CodeGen.sortBlocks
  CodeGen.store
  CodeGen.terminator
  CodeGen.unikName
  CodeGen.BlockState{CodeGen.BlockState idx stack term}
  CodeGen.Codegen{CodeGen.Codegen runCodegen}
  CodeGen.CodegenState{CodeGen.CodegenState blockCount blocks count currentBlock names symtab}
  CodeGen.LLVM{CodeGen.LLVM}
  CodeGen.Names
  CodeGen.SymbolTable
module dependencies: AST
package dependencies: array-0.5.1.1@array-0.5.1.1 base-4.9.1.0
                      binary-0.8.3.0@binary-0.8.3.0
                      bytestring-0.10.8.1@bytestring-0.10.8.1
                      containers-0.5.7.1@containers-0.5.7.1
                      deepseq-1.4.2.0@deepseq-1.4.2.0 ghc-boot-th-8.0.2@ghc-boot-th-8.0.2
                      ghc-prim-0.5.0.0 integer-gmp-1.0.0.1
                      llvm-hs-4.0.1.0@llvm-hs-4.0.1.0-7zNtSbHzHexJcgnwmG0bn2
                      llvm-hs-pure-4.0.0.0@llvm-hs-pure-4.0.0.0-2EKQPzemceCEww6fPxl71c
                      mtl-2.2.1@mtl-2.2.1-BLKBelFsPB3BoFeSWSOYj6
                      parsec-3.1.11@parsec-3.1.11-113irVHGgd88sRnywByDNw
                      pretty-1.1.3.3@pretty-1.1.3.3 template-haskell-2.11.1.0
                      text-1.2.2.1@text-1.2.2.1-Ji7hMs2U4BkBwavd4taEVR
                      transformers-0.5.2.0@transformers-0.5.2.0
                      utf8-string-1.0.1.1@utf8-string-1.0.1.1-1DpjxLeTvGg7ttZZojxJR5
orphans: base-4.9.1.0:GHC.Base base-4.9.1.0:GHC.Float
         binary-0.8.3.0@binary-0.8.3.0:Data.Binary.Generic
         bytestring-0.10.8.1@bytestring-0.10.8.1:Data.ByteString.Builder
         llvm-hs-4.0.1.0@llvm-hs-4.0.1.0-7zNtSbHzHexJcgnwmG0bn2:Control.Monad.AnyCont
         llvm-hs-4.0.1.0@llvm-hs-4.0.1.0-7zNtSbHzHexJcgnwmG0bn2:LLVM.Internal.Atomicity
         llvm-hs-4.0.1.0@llvm-hs-4.0.1.0-7zNtSbHzHexJcgnwmG0bn2:LLVM.Internal.Attribute
         llvm-hs-4.0.1.0@llvm-hs-4.0.1.0-7zNtSbHzHexJcgnwmG0bn2:LLVM.Internal.CallingConvention
         llvm-hs-4.0.1.0@llvm-hs-4.0.1.0-7zNtSbHzHexJcgnwmG0bn2:LLVM.Internal.Constant
         llvm-hs-4.0.1.0@llvm-hs-4.0.1.0-7zNtSbHzHexJcgnwmG0bn2:LLVM.Internal.EncodeAST
         llvm-hs-4.0.1.0@llvm-hs-4.0.1.0-7zNtSbHzHexJcgnwmG0bn2:LLVM.Internal.FFI.LLVMCTypes
         llvm-hs-4.0.1.0@llvm-hs-4.0.1.0-7zNtSbHzHexJcgnwmG0bn2:LLVM.Internal.FastMathFlags
         llvm-hs-4.0.1.0@llvm-hs-4.0.1.0-7zNtSbHzHexJcgnwmG0bn2:LLVM.Internal.FloatingPointPredicate
         llvm-hs-4.0.1.0@llvm-hs-4.0.1.0-7zNtSbHzHexJcgnwmG0bn2:LLVM.Internal.Global
         llvm-hs-4.0.1.0@llvm-hs-4.0.1.0-7zNtSbHzHexJcgnwmG0bn2:LLVM.Internal.InlineAssembly
         llvm-hs-4.0.1.0@llvm-hs-4.0.1.0-7zNtSbHzHexJcgnwmG0bn2:LLVM.Internal.Instruction
         llvm-hs-4.0.1.0@llvm-hs-4.0.1.0-7zNtSbHzHexJcgnwmG0bn2:LLVM.Internal.IntegerPredicate
         llvm-hs-4.0.1.0@llvm-hs-4.0.1.0-7zNtSbHzHexJcgnwmG0bn2:LLVM.Internal.MemoryBuffer
         llvm-hs-4.0.1.0@llvm-hs-4.0.1.0-7zNtSbHzHexJcgnwmG0bn2:LLVM.Internal.Metadata
         llvm-hs-4.0.1.0@llvm-hs-4.0.1.0-7zNtSbHzHexJcgnwmG0bn2:LLVM.Internal.Module
         llvm-hs-4.0.1.0@llvm-hs-4.0.1.0-7zNtSbHzHexJcgnwmG0bn2:LLVM.Internal.Operand
         llvm-hs-4.0.1.0@llvm-hs-4.0.1.0-7zNtSbHzHexJcgnwmG0bn2:LLVM.Internal.RMWOperation
         llvm-hs-4.0.1.0@llvm-hs-4.0.1.0-7zNtSbHzHexJcgnwmG0bn2:LLVM.Internal.String
         llvm-hs-4.0.1.0@llvm-hs-4.0.1.0-7zNtSbHzHexJcgnwmG0bn2:LLVM.Internal.TailCallKind
         llvm-hs-4.0.1.0@llvm-hs-4.0.1.0-7zNtSbHzHexJcgnwmG0bn2:LLVM.Internal.Target
         llvm-hs-4.0.1.0@llvm-hs-4.0.1.0-7zNtSbHzHexJcgnwmG0bn2:LLVM.Internal.Type
         text-1.2.2.1@text-1.2.2.1-Ji7hMs2U4BkBwavd4taEVR:Data.Text
         text-1.2.2.1@text-1.2.2.1-Ji7hMs2U4BkBwavd4taEVR:Data.Text.Lazy
         text-1.2.2.1@text-1.2.2.1-Ji7hMs2U4BkBwavd4taEVR:Data.Text.Show
         transformers-0.5.2.0@transformers-0.5.2.0:Control.Monad.Trans.Error
family instance modules: base-4.9.1.0:Control.Applicative
                         base-4.9.1.0:Data.Complex base-4.9.1.0:Data.Either
                         base-4.9.1.0:Data.Functor.Const base-4.9.1.0:Data.Functor.Identity
                         base-4.9.1.0:Data.List.NonEmpty base-4.9.1.0:Data.Monoid
                         base-4.9.1.0:Data.Semigroup base-4.9.1.0:Data.Type.Equality
                         base-4.9.1.0:Data.Version base-4.9.1.0:Data.Void
                         base-4.9.1.0:GHC.Exts base-4.9.1.0:GHC.Generics
                         base-4.9.1.0:GHC.IO.Exception base-4.9.1.0:GHC.TypeLits
                         containers-0.5.7.1@containers-0.5.7.1:Data.IntMap.Base
                         containers-0.5.7.1@containers-0.5.7.1:Data.IntSet.Base
                         containers-0.5.7.1@containers-0.5.7.1:Data.Map.Base
                         containers-0.5.7.1@containers-0.5.7.1:Data.Sequence
                         containers-0.5.7.1@containers-0.5.7.1:Data.Set.Base
                         ghc-boot-th-8.0.2@ghc-boot-th-8.0.2:GHC.LanguageExtensions.Type
                         pretty-1.1.3.3@pretty-1.1.3.3:Text.PrettyPrint.Annotated.HughesPJ
                         pretty-1.1.3.3@pretty-1.1.3.3:Text.PrettyPrint.HughesPJ
                         template-haskell-2.11.1.0:Language.Haskell.TH.Syntax
                         text-1.2.2.1@text-1.2.2.1-Ji7hMs2U4BkBwavd4taEVR:Data.Text
                         text-1.2.2.1@text-1.2.2.1-Ji7hMs2U4BkBwavd4taEVR:Data.Text.Lazy
import  -/  AST 7766b3f629d0c491c3020be7c559cd28
  exports: 5de5e88fd103c6732877d9f684527203
  ArgList 938a528b4930e229d3ec647e96cab48f
  Declaration 33d432a2601c6e2c29dde14013901097
  ExternDecl 91d7bf81761177475f53629426cbe57c
  Func 901f27f2099af38bfcc39d4ad6579d8e
  Func 2c82732cb23ac10238193b154494d0d4
  IntC 9ade21acee03e11644bc8ac417bc95b6
  Name 1259c2391d401e2b054e422bbb9873f0
  Type d08edfa29578fe246282f45c5f5b1a4f
import  -/  base-4.9.1.0:Control.Applicative 32430a90492e727f4bd80db71c28600c
import  -/  base-4.9.1.0:Data.Function 7aca86bfbd92366def5f260e30cb2628
import  -/  base-4.9.1.0:Data.Functor.Identity 6ee67943d44d50091e12d22df04741f0
import  -/  base-4.9.1.0:Data.Int 07f5a36c488acfe0ac32e81c7536b8ff
import  -/  base-4.9.1.0:Data.List 07ae2acca6538aa0800bd0a993ac6ac1
import  -/  base-4.9.1.0:Data.OldList 27987919d8da2f92e3f472ca81f730f8
import  -/  base-4.9.1.0:Data.String b34df69c7b6358cd40a379c8a0a78dcf
import  -/  base-4.9.1.0:Data.Tuple 7dc4bbb45d2e69c991ffac438beeca11
import  -/  base-4.9.1.0:Data.Word 77f42e01d0fb6b071f1ea2176d87fa6c
import  -/  base-4.9.1.0:GHC.Base c4231c43c07e46080a26bf94094c7aa1
import  -/  base-4.9.1.0:GHC.Err 3bba35a16538d33d424682ce66876cdd
import  -/  base-4.9.1.0:GHC.List ab8c4e523e6c479c549d3bcd5fc4a439
import  -/  base-4.9.1.0:GHC.Num 00bfaa7b2f9d6084913c0697a8a49ec8
import  -/  base-4.9.1.0:GHC.Show a027f5ac24879eaba752f44aa90fe511
import  -/  base-4.9.1.0:Prelude 22dd289b8469a8fa8dc81cab7b237771
import  -/  containers-0.5.7.1@containers-0.5.7.1:Data.Map 20d4ffbee41965d03d6a989425473dc4
import  -/  containers-0.5.7.1@containers-0.5.7.1:Data.Map.Base d432f6875983131473086af8cb290590
import  -/  ghc-prim-0.5.0.0:GHC.Classes 0bdf3d057a415ec1b84a7b1994efbe47
import  -/  llvm-hs-4.0.1.0@llvm-hs-4.0.1.0-7zNtSbHzHexJcgnwmG0bn2:LLVM.Context 3ff979012af98bb0509b3c7237b2e52a
import  -/  llvm-hs-4.0.1.0@llvm-hs-4.0.1.0-7zNtSbHzHexJcgnwmG0bn2:LLVM.Module 177870c7e951c7d81f272cd33a027da8
import  -/  llvm-hs-pure-4.0.0.0@llvm-hs-pure-4.0.0.0-2EKQPzemceCEww6fPxl71c:LLVM.AST 47038b0f748769b63f8076369b1a33fb
import  -/  llvm-hs-pure-4.0.0.0@llvm-hs-pure-4.0.0.0-2EKQPzemceCEww6fPxl71c:LLVM.AST.Constant a78d56557db9674ef236577d1b57dc4a
import  -/  llvm-hs-pure-4.0.0.0@llvm-hs-pure-4.0.0.0-2EKQPzemceCEww6fPxl71c:LLVM.AST.Float 08df23a7019fe65998cb16e8349f5d71
import  -/  llvm-hs-pure-4.0.0.0@llvm-hs-pure-4.0.0.0-2EKQPzemceCEww6fPxl71c:LLVM.AST.FloatingPointPredicate f358b7bdbc6af687fc4359b85acfdc11
import  -/  llvm-hs-pure-4.0.0.0@llvm-hs-pure-4.0.0.0-2EKQPzemceCEww6fPxl71c:LLVM.AST.Global dc9967ab0a54a8c248526068fed8c7e2
import  -/  llvm-hs-pure-4.0.0.0@llvm-hs-pure-4.0.0.0-2EKQPzemceCEww6fPxl71c:LLVM.AST.Instruction 7273bebee67e82826af4d75782172183
import  -/  llvm-hs-pure-4.0.0.0@llvm-hs-pure-4.0.0.0-2EKQPzemceCEww6fPxl71c:LLVM.AST.Linkage 5778f53b60040650c73fa2d0c506d52b
import  -/  llvm-hs-pure-4.0.0.0@llvm-hs-pure-4.0.0.0-2EKQPzemceCEww6fPxl71c:LLVM.AST.Name 3bf2310ba5c2808b0669a0beb60812ae
import  -/  llvm-hs-pure-4.0.0.0@llvm-hs-pure-4.0.0.0-2EKQPzemceCEww6fPxl71c:LLVM.AST.Operand 6c5218d5c26cd81924b6dad4be8916de
import  -/  llvm-hs-pure-4.0.0.0@llvm-hs-pure-4.0.0.0-2EKQPzemceCEww6fPxl71c:LLVM.AST.Type 86384745fc49893773d392992fb59ace
import  -/  mtl-2.2.1@mtl-2.2.1-BLKBelFsPB3BoFeSWSOYj6:Control.Monad.Except 3bb0e2598193c1ba00c9723945e93004
import  -/  mtl-2.2.1@mtl-2.2.1-BLKBelFsPB3BoFeSWSOYj6:Control.Monad.State 749dca8ca0e6625b32091d445bd92b01
import  -/  mtl-2.2.1@mtl-2.2.1-BLKBelFsPB3BoFeSWSOYj6:Control.Monad.State.Class 6d31234b0a911b56412061943d18b89e
import  -/  transformers-0.5.2.0@transformers-0.5.2.0:Control.Monad.Trans.State.Lazy 371607e50dde46b5f4103b3ab334a497
d444e13d91ea16d54346634829ba461d
  $fApplicativeCodegen :: GHC.Base.Applicative CodeGen.Codegen
  DFunId
  {- Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ CodeGen.Codegen
                  CodeGen.$fFunctorCodegen
                  CodeGen.$fApplicativeCodegen_$cpure
                  CodeGen.$fApplicativeCodegen_$c<*>
                  CodeGen.$fApplicativeCodegen_$c*>
                  CodeGen.$fApplicativeCodegen_$c<* -}
394a715fb85ad8c6e664c41b74648b44
  $fApplicativeCodegen1 ::
    Control.Monad.Trans.State.Lazy.StateT
      CodeGen.CodegenState Data.Functor.Identity.Identity a
    -> Control.Monad.Trans.State.Lazy.StateT
         CodeGen.CodegenState Data.Functor.Identity.Identity b
    -> CodeGen.CodegenState
    -> Data.Functor.Identity.Identity (a, CodeGen.CodegenState)
  {- Arity: 3,
     Unfolding: (\ @ b @ a ->
                 Control.Monad.Trans.State.Lazy.$fApplicativeStateT1
                   @ Data.Functor.Identity.Identity
                   @ CodeGen.CodegenState
                   Data.Functor.Identity.$fFunctorIdentity
                   Data.Functor.Identity.$fMonadIdentity
                   @ a
                   @ b) -}
13bbc2a31100d2ad8bf81c848b4795e3
  $fApplicativeCodegen2 ::
    Control.Monad.Trans.State.Lazy.StateT
      CodeGen.CodegenState Data.Functor.Identity.Identity a
    -> Control.Monad.Trans.State.Lazy.StateT
         CodeGen.CodegenState Data.Functor.Identity.Identity b
    -> CodeGen.CodegenState
    -> Data.Functor.Identity.Identity (b, CodeGen.CodegenState)
  {- Arity: 3,
     Unfolding: (\ @ b @ a ->
                 Control.Monad.Trans.State.Lazy.$fApplicativeStateT3
                   @ Data.Functor.Identity.Identity
                   @ CodeGen.CodegenState
                   Data.Functor.Identity.$fFunctorIdentity
                   Data.Functor.Identity.$fMonadIdentity
                   @ a
                   @ b) -}
d444e13d91ea16d54346634829ba461d
  $fApplicativeCodegen_$c*> ::
    CodeGen.Codegen a -> CodeGen.Codegen b -> CodeGen.Codegen b
  {- Arity: 3,
     Unfolding: InlineRule (0, True, True)
                (\ @ a @ b -> CodeGen.$fApplicativeCodegen2 @ b @ a)
                  `cast`
                (forall (a :: <*>_N) (b :: <*>_N).
                 Sym (CodeGen.N:Codegen[0]) <a>_N
                 ->_R Sym (CodeGen.N:Codegen[0]) <b>_N
                 ->_R Trans
                          (Sym (Control.Monad.Trans.State.Lazy.N:StateT[0]
                                    <CodeGen.CodegenState>_N
                                    <Data.Functor.Identity.Identity>_R
                                    <b>_N))
                          (Sym (CodeGen.N:Codegen[0]) <b>_N)) -}
d444e13d91ea16d54346634829ba461d
  $fApplicativeCodegen_$c<* ::
    CodeGen.Codegen a -> CodeGen.Codegen b -> CodeGen.Codegen a
  {- Arity: 3,
     Unfolding: InlineRule (0, True, True)
                (\ @ a @ b -> CodeGen.$fApplicativeCodegen1 @ b @ a)
                  `cast`
                (forall (a :: <*>_N) (b :: <*>_N).
                 Sym (CodeGen.N:Codegen[0]) <a>_N
                 ->_R Sym (CodeGen.N:Codegen[0]) <b>_N
                 ->_R Trans
                          (Sym (Control.Monad.Trans.State.Lazy.N:StateT[0]
                                    <CodeGen.CodegenState>_N
                                    <Data.Functor.Identity.Identity>_R
                                    <a>_N))
                          (Sym (CodeGen.N:Codegen[0]) <a>_N)) -}
d444e13d91ea16d54346634829ba461d
  $fApplicativeCodegen_$c<*> ::
    CodeGen.Codegen (a -> b) -> CodeGen.Codegen a -> CodeGen.Codegen b
  {- Arity: 3, HasNoCafRefs,
     Strictness: <L,1*C1(U(U,U))><L,1*C1(U(U,U))><L,U>m,
     Unfolding: InlineRule (0, True, True)
                (CodeGen.$fApplicativeCodegen_$s$fApplicativeStateT_$c<*>
                   @ CodeGen.CodegenState)
                  `cast`
                (forall (a :: <*>_N) (b :: <*>_N).
                 Sym (CodeGen.N:Codegen[0]) <a -> b>_N
                 ->_R Sym (CodeGen.N:Codegen[0]) <a>_N
                 ->_R Sym (CodeGen.N:Codegen[0]) <b>_N) -}
d444e13d91ea16d54346634829ba461d
  $fApplicativeCodegen_$cpure :: a -> CodeGen.Codegen a
  {- Arity: 2, HasNoCafRefs, Strictness: <L,U><L,U>m,
     Unfolding: InlineRule (0, True, True)
                (CodeGen.$fApplicativeCodegen_$s$fApplicativeStateT_$cpure
                   @ CodeGen.CodegenState)
                  `cast`
                (forall (a :: <*>_N).
                 <a>_R ->_R Sym (CodeGen.N:Codegen[0]) <a>_N) -}
21eabbcf3ba14e6af9dc015ec2c0d9f6
  $fApplicativeCodegen_$s$fApplicativeStateT_$c<*> ::
    Control.Monad.Trans.State.Lazy.StateT
      s Data.Functor.Identity.Identity (a -> b)
    -> Control.Monad.Trans.State.Lazy.StateT
         s Data.Functor.Identity.Identity a
    -> Control.Monad.Trans.State.Lazy.StateT
         s Data.Functor.Identity.Identity b
  {- Arity: 3, HasNoCafRefs,
     Strictness: <L,1*C1(U(U,U))><L,1*C1(U(U,U))><L,U>m,
     Inline: INLINE (sat-args=2),
     Unfolding: InlineRule (2, False, False)
                (\ @ s
                   @ a
                   @ b
                   (ds :: Control.Monad.Trans.State.Lazy.StateT
                            s Data.Functor.Identity.Identity (a -> b))
                   (ds1 :: Control.Monad.Trans.State.Lazy.StateT
                             s Data.Functor.Identity.Identity a) ->
                 GHC.Base.$
                   @ 'GHC.Types.PtrRepLifted
                   @ (s -> Data.Functor.Identity.Identity (b, s))
                   @ (Control.Monad.Trans.State.Lazy.StateT
                        s Data.Functor.Identity.Identity b)
                   (\ (tpl :: s -> Data.Functor.Identity.Identity (b, s)) -> tpl)
                     `cast`
                   (<s -> Data.Functor.Identity.Identity (b, s)>_R
                    ->_R Sym (Control.Monad.Trans.State.Lazy.N:StateT[0]
                                  <s>_N <Data.Functor.Identity.Identity>_R <b>_N))
                   (\ (s1 :: s) ->
                    Data.Functor.Identity.$fMonadIdentity_$c>>=
                      @ (a -> b, s)
                      @ (b, s)
                      (ds
                         `cast`
                       (Control.Monad.Trans.State.Lazy.N:StateT[0]
                            <s>_N <Data.Functor.Identity.Identity>_R <a -> b>_N)
                         s1)
                      (\ (ds2 :: (a -> b, s))[OneShot] ->
                       Data.Functor.Identity.$fMonadIdentity_$c>>=
                         @ (a, s)
                         @ (b, s)
                         (ds1
                            `cast`
                          (Control.Monad.Trans.State.Lazy.N:StateT[0]
                               <s>_N <Data.Functor.Identity.Identity>_R <a>_N)
                            (case ds2 of wild { (,) f s' -> s' }))
                         (\ (ds3 :: (a, s))[OneShot] ->
                          Data.Functor.Identity.$fApplicativeIdentity_$cpure
                            @ (b, s)
                            (case ds2 of wild { (,) f s' ->
                             f (case ds3 of wild1 { (,) x s'' -> x }) },
                             case ds3 of wild { (,) x s'' -> s'' }))))) -}
7ec4eea47b5b21ea0c06ed4cf2dae62a
  $fApplicativeCodegen_$s$fApplicativeStateT_$cpure ::
    a
    -> Control.Monad.Trans.State.Lazy.StateT
         s Data.Functor.Identity.Identity a
  {- Arity: 2, HasNoCafRefs, Strictness: <L,U><L,U>m,
     Inline: INLINE (sat-args=1),
     Unfolding: InlineRule (1, False, False)
                (\ @ s @ a (a1 :: a) ->
                 GHC.Base.$
                   @ 'GHC.Types.PtrRepLifted
                   @ (s -> Data.Functor.Identity.Identity (a, s))
                   @ (Control.Monad.Trans.State.Lazy.StateT
                        s Data.Functor.Identity.Identity a)
                   (\ (tpl :: s -> Data.Functor.Identity.Identity (a, s)) -> tpl)
                     `cast`
                   (<s -> Data.Functor.Identity.Identity (a, s)>_R
                    ->_R Sym (Control.Monad.Trans.State.Lazy.N:StateT[0]
                                  <s>_N <Data.Functor.Identity.Identity>_R <a>_N))
                   (\ (s1 :: s) ->
                    Data.Functor.Identity.$fApplicativeIdentity_$cpure
                      @ (a, s)
                      (a1, s1))) -}
1d1e1a70335092265202f3dd4938f3fb
  $fApplicativeLLVM :: GHC.Base.Applicative CodeGen.LLVM
  DFunId
  {- Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ CodeGen.LLVM
                  CodeGen.$fFunctorLLVM
                  CodeGen.$fApplicativeLLVM_$cpure
                  CodeGen.$fApplicativeLLVM_$c<*>
                  CodeGen.$fApplicativeLLVM_$c*>
                  CodeGen.$fApplicativeLLVM_$c<* -}
72b03a077d4272b40152b5c16c43e30f
  $fApplicativeLLVM1 ::
    Control.Monad.Trans.State.Lazy.StateT
      LLVM.AST.Module Data.Functor.Identity.Identity a
    -> Control.Monad.Trans.State.Lazy.StateT
         LLVM.AST.Module Data.Functor.Identity.Identity b
    -> LLVM.AST.Module
    -> Data.Functor.Identity.Identity (a, LLVM.AST.Module)
  {- Arity: 3,
     Unfolding: (\ @ b @ a ->
                 Control.Monad.Trans.State.Lazy.$fApplicativeStateT1
                   @ Data.Functor.Identity.Identity
                   @ LLVM.AST.Module
                   Data.Functor.Identity.$fFunctorIdentity
                   Data.Functor.Identity.$fMonadIdentity
                   @ a
                   @ b) -}
8494a5ace3d96ced2443606b4ed11e12
  $fApplicativeLLVM2 ::
    Control.Monad.Trans.State.Lazy.StateT
      LLVM.AST.Module Data.Functor.Identity.Identity a
    -> Control.Monad.Trans.State.Lazy.StateT
         LLVM.AST.Module Data.Functor.Identity.Identity b
    -> LLVM.AST.Module
    -> Data.Functor.Identity.Identity (b, LLVM.AST.Module)
  {- Arity: 3,
     Unfolding: (\ @ b @ a ->
                 Control.Monad.Trans.State.Lazy.$fApplicativeStateT3
                   @ Data.Functor.Identity.Identity
                   @ LLVM.AST.Module
                   Data.Functor.Identity.$fFunctorIdentity
                   Data.Functor.Identity.$fMonadIdentity
                   @ a
                   @ b) -}
1d1e1a70335092265202f3dd4938f3fb
  $fApplicativeLLVM_$c*> ::
    CodeGen.LLVM a -> CodeGen.LLVM b -> CodeGen.LLVM b
  {- Arity: 3,
     Unfolding: InlineRule (0, True, True)
                (\ @ a @ b -> CodeGen.$fApplicativeLLVM2 @ b @ a)
                  `cast`
                (forall (a :: <*>_N) (b :: <*>_N).
                 Sym (CodeGen.N:LLVM[0]) <a>_N
                 ->_R Sym (CodeGen.N:LLVM[0]) <b>_N
                 ->_R Trans
                          (Sym (Control.Monad.Trans.State.Lazy.N:StateT[0]
                                    <LLVM.AST.Module>_N <Data.Functor.Identity.Identity>_R <b>_N))
                          (Sym (CodeGen.N:LLVM[0]) <b>_N)) -}
1d1e1a70335092265202f3dd4938f3fb
  $fApplicativeLLVM_$c<* ::
    CodeGen.LLVM a -> CodeGen.LLVM b -> CodeGen.LLVM a
  {- Arity: 3,
     Unfolding: InlineRule (0, True, True)
                (\ @ a @ b -> CodeGen.$fApplicativeLLVM1 @ b @ a)
                  `cast`
                (forall (a :: <*>_N) (b :: <*>_N).
                 Sym (CodeGen.N:LLVM[0]) <a>_N
                 ->_R Sym (CodeGen.N:LLVM[0]) <b>_N
                 ->_R Trans
                          (Sym (Control.Monad.Trans.State.Lazy.N:StateT[0]
                                    <LLVM.AST.Module>_N <Data.Functor.Identity.Identity>_R <a>_N))
                          (Sym (CodeGen.N:LLVM[0]) <a>_N)) -}
1d1e1a70335092265202f3dd4938f3fb
  $fApplicativeLLVM_$c<*> ::
    CodeGen.LLVM (a -> b) -> CodeGen.LLVM a -> CodeGen.LLVM b
  {- Arity: 3, HasNoCafRefs,
     Strictness: <L,1*C1(U(U,U))><L,1*C1(U(U,U))><L,U>m,
     Unfolding: InlineRule (0, True, True)
                (CodeGen.$fApplicativeCodegen_$s$fApplicativeStateT_$c<*>
                   @ LLVM.AST.Module)
                  `cast`
                (forall (a :: <*>_N) (b :: <*>_N).
                 Sym (CodeGen.N:LLVM[0]) <a -> b>_N
                 ->_R Sym (CodeGen.N:LLVM[0]) <a>_N
                 ->_R Sym (CodeGen.N:LLVM[0]) <b>_N) -}
1d1e1a70335092265202f3dd4938f3fb
  $fApplicativeLLVM_$cpure :: a -> CodeGen.LLVM a
  {- Arity: 2, HasNoCafRefs, Strictness: <L,U><L,U>m,
     Unfolding: InlineRule (0, True, True)
                (CodeGen.$fApplicativeCodegen_$s$fApplicativeStateT_$cpure
                   @ LLVM.AST.Module)
                  `cast`
                (forall (a :: <*>_N). <a>_R ->_R Sym (CodeGen.N:LLVM[0]) <a>_N) -}
d444e13d91ea16d54346634829ba461d
  $fFunctorCodegen :: GHC.Base.Functor CodeGen.Codegen
  DFunId
  {- HasNoCafRefs, Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ CodeGen.Codegen
                  CodeGen.$fFunctorCodegen_$cfmap
                  CodeGen.$fFunctorCodegen_$c<$ -}
7dd2136054a2b97a8091eb71df05753e
  $fFunctorCodegen1 ::
    a
    -> Control.Monad.Trans.State.Lazy.StateT
         CodeGen.CodegenState Data.Functor.Identity.Identity b
    -> CodeGen.CodegenState
    -> (a, CodeGen.CodegenState)
  {- Arity: 3, HasNoCafRefs,
     Strictness: <L,U><L,1*C1(U(A,1*U))><L,U>m,
     Unfolding: InlineRule (3, True, False)
                (\ @ a
                   @ b
                   (eta :: a)
                   (eta1 :: Control.Monad.Trans.State.Lazy.StateT
                              CodeGen.CodegenState Data.Functor.Identity.Identity b)
                   (s1 :: CodeGen.CodegenState) ->
                 (eta,
                  case (eta1
                          `cast`
                        (Control.Monad.Trans.State.Lazy.N:StateT[0]
                             <CodeGen.CodegenState>_N <Data.Functor.Identity.Identity>_R <b>_N)
                          s1)
                         `cast`
                       (Data.Functor.Identity.N:Identity[0]
                            <(b, CodeGen.CodegenState)>_R) of wild { (,) a1 s' ->
                  s' })) -}
d444e13d91ea16d54346634829ba461d
  $fFunctorCodegen_$c<$ ::
    a -> CodeGen.Codegen b -> CodeGen.Codegen a
  {- Arity: 3, HasNoCafRefs,
     Strictness: <L,U><L,1*C1(U(A,1*U))><L,U>m,
     Unfolding: InlineRule (0, True, True)
                CodeGen.$fFunctorCodegen1
                  `cast`
                (forall (a :: <*>_N) (b :: <*>_N).
                 <a>_R
                 ->_R Sym (CodeGen.N:Codegen[0]) <b>_N
                 ->_R Trans
                          (<CodeGen.CodegenState>_R
                           ->_R Sym (Data.Functor.Identity.N:Identity[0]
                                         <(a, CodeGen.CodegenState)>_R))
                          (Trans
                               (Sym (Control.Monad.Trans.State.Lazy.N:StateT[0]
                                         <CodeGen.CodegenState>_N
                                         <Data.Functor.Identity.Identity>_R
                                         <a>_N))
                               (Sym (CodeGen.N:Codegen[0]) <a>_N))) -}
d444e13d91ea16d54346634829ba461d
  $fFunctorCodegen_$cfmap ::
    (a -> b) -> CodeGen.Codegen a -> CodeGen.Codegen b
  {- Arity: 3, HasNoCafRefs,
     Strictness: <L,1*C1(U)><L,1*C1(U(U,U))><L,U>m,
     Unfolding: InlineRule (0, True, True)
                (CodeGen.$fFunctorCodegen_$s$fFunctorStateT_$cfmap
                   @ CodeGen.CodegenState)
                  `cast`
                (forall (a :: <*>_N) (b :: <*>_N).
                 <a -> b>_R
                 ->_R Sym (CodeGen.N:Codegen[0]) <a>_N
                 ->_R Sym (CodeGen.N:Codegen[0]) <b>_N) -}
08a702b017b6fba9b2873d40c530ddc6
  $fFunctorCodegen_$s$fFunctorStateT_$cfmap ::
    (a -> b)
    -> Control.Monad.Trans.State.Lazy.StateT
         s Data.Functor.Identity.Identity a
    -> Control.Monad.Trans.State.Lazy.StateT
         s Data.Functor.Identity.Identity b
  {- Arity: 3, HasNoCafRefs,
     Strictness: <L,1*C1(U)><L,1*C1(U(U,U))><L,U>m,
     Inline: INLINE (sat-args=2),
     Unfolding: InlineRule (2, False, False)
                (\ @ s
                   @ a
                   @ b
                   (f :: a -> b)
                   (m1 :: Control.Monad.Trans.State.Lazy.StateT
                            s Data.Functor.Identity.Identity a) ->
                 GHC.Base.$
                   @ 'GHC.Types.PtrRepLifted
                   @ (s -> Data.Functor.Identity.Identity (b, s))
                   @ (Control.Monad.Trans.State.Lazy.StateT
                        s Data.Functor.Identity.Identity b)
                   (\ (tpl :: s -> Data.Functor.Identity.Identity (b, s)) -> tpl)
                     `cast`
                   (<s -> Data.Functor.Identity.Identity (b, s)>_R
                    ->_R Sym (Control.Monad.Trans.State.Lazy.N:StateT[0]
                                  <s>_N <Data.Functor.Identity.Identity>_R <b>_N))
                   (\ (s1 :: s) ->
                    GHC.Base.$
                      @ 'GHC.Types.PtrRepLifted
                      @ (Data.Functor.Identity.Identity (a, s))
                      @ (Data.Functor.Identity.Identity (b, s))
                      (Data.Functor.Identity.$fFunctorIdentity_$cfmap
                         @ (a, s)
                         @ (b, s)
                         (\ (ds :: (a, s)) ->
                          (f (case ds of wild { (,) a1 s' -> a1 }),
                           case ds of wild { (,) a1 s' -> s' })))
                      (Control.Monad.Trans.State.Lazy.runStateT
                         @ s
                         @ Data.Functor.Identity.Identity
                         @ a
                         m1
                         s1))) -}
1d1e1a70335092265202f3dd4938f3fb
  $fFunctorLLVM :: GHC.Base.Functor CodeGen.LLVM
  DFunId
  {- HasNoCafRefs, Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ CodeGen.LLVM
                  CodeGen.$fFunctorLLVM_$cfmap
                  CodeGen.$fFunctorLLVM_$c<$ -}
6b5f0a6e9e8513297f29ad333b5968a8
  $fFunctorLLVM1 ::
    a
    -> Control.Monad.Trans.State.Lazy.StateT
         LLVM.AST.Module Data.Functor.Identity.Identity b
    -> LLVM.AST.Module
    -> (a, LLVM.AST.Module)
  {- Arity: 3, HasNoCafRefs,
     Strictness: <L,U><L,1*C1(U(A,1*U))><L,U>m,
     Unfolding: InlineRule (3, True, False)
                (\ @ a
                   @ b
                   (eta :: a)
                   (eta1 :: Control.Monad.Trans.State.Lazy.StateT
                              LLVM.AST.Module Data.Functor.Identity.Identity b)
                   (s1 :: LLVM.AST.Module) ->
                 (eta,
                  case (eta1
                          `cast`
                        (Control.Monad.Trans.State.Lazy.N:StateT[0]
                             <LLVM.AST.Module>_N <Data.Functor.Identity.Identity>_R <b>_N)
                          s1)
                         `cast`
                       (Data.Functor.Identity.N:Identity[0]
                            <(b, LLVM.AST.Module)>_R) of wild { (,) a1 s' ->
                  s' })) -}
1d1e1a70335092265202f3dd4938f3fb
  $fFunctorLLVM_$c<$ :: a -> CodeGen.LLVM b -> CodeGen.LLVM a
  {- Arity: 3, HasNoCafRefs,
     Strictness: <L,U><L,1*C1(U(A,1*U))><L,U>m,
     Unfolding: InlineRule (0, True, True)
                CodeGen.$fFunctorLLVM1
                  `cast`
                (forall (a :: <*>_N) (b :: <*>_N).
                 <a>_R
                 ->_R Sym (CodeGen.N:LLVM[0]) <b>_N
                 ->_R Trans
                          (<LLVM.AST.Module>_R
                           ->_R Sym (Data.Functor.Identity.N:Identity[0]
                                         <(a, LLVM.AST.Module)>_R))
                          (Trans
                               (Sym (Control.Monad.Trans.State.Lazy.N:StateT[0]
                                         <LLVM.AST.Module>_N
                                         <Data.Functor.Identity.Identity>_R
                                         <a>_N))
                               (Sym (CodeGen.N:LLVM[0]) <a>_N))) -}
1d1e1a70335092265202f3dd4938f3fb
  $fFunctorLLVM_$cfmap ::
    (a -> b) -> CodeGen.LLVM a -> CodeGen.LLVM b
  {- Arity: 3, HasNoCafRefs,
     Strictness: <L,1*C1(U)><L,1*C1(U(U,U))><L,U>m,
     Unfolding: InlineRule (0, True, True)
                (CodeGen.$fFunctorCodegen_$s$fFunctorStateT_$cfmap
                   @ LLVM.AST.Module)
                  `cast`
                (forall (a :: <*>_N) (b :: <*>_N).
                 <a -> b>_R
                 ->_R Sym (CodeGen.N:LLVM[0]) <a>_N
                 ->_R Sym (CodeGen.N:LLVM[0]) <b>_N) -}
d444e13d91ea16d54346634829ba461d
  $fMonadCodegen :: GHC.Base.Monad CodeGen.Codegen
  DFunId
  {- Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ CodeGen.Codegen
                  CodeGen.$fApplicativeCodegen
                  CodeGen.$fMonadCodegen_$c>>=
                  CodeGen.$fMonadCodegen_$c>>
                  CodeGen.$fMonadCodegen_$creturn
                  CodeGen.$fMonadCodegen_$cfail -}
d444e13d91ea16d54346634829ba461d
  $fMonadCodegen_$c>> ::
    CodeGen.Codegen a -> CodeGen.Codegen b -> CodeGen.Codegen b
  {- Arity: 3, HasNoCafRefs,
     Strictness: <L,1*C1(U(A,1*U))><C(S),1*C1(U(U,U))><L,U>,
     Unfolding: InlineRule (0, True, True)
                (CodeGen.$fMonadCodegen_$s$fMonadStateT_$c>>
                   @ CodeGen.CodegenState)
                  `cast`
                (forall (a :: <*>_N) (b :: <*>_N).
                 Sym (CodeGen.N:Codegen[0]) <a>_N
                 ->_R Sym (CodeGen.N:Codegen[0]) <b>_N
                 ->_R Sym (CodeGen.N:Codegen[0]) <b>_N) -}
d444e13d91ea16d54346634829ba461d
  $fMonadCodegen_$c>>= ::
    CodeGen.Codegen a -> (a -> CodeGen.Codegen b) -> CodeGen.Codegen b
  {- Arity: 3, HasNoCafRefs,
     Strictness: <L,1*C1(U(U,U))><C(C(S)),1*C1(C1(U(U,U)))><L,U>,
     Unfolding: InlineRule (0, True, True)
                (CodeGen.$fMonadCodegen_$s$fMonadStateT_$c>>=
                   @ CodeGen.CodegenState)
                  `cast`
                (forall (a :: <*>_N) (b :: <*>_N).
                 Sym (CodeGen.N:Codegen[0]) <a>_N
                 ->_R (<a>_R ->_R Sym (CodeGen.N:Codegen[0]) <b>_N)
                 ->_R Sym (CodeGen.N:Codegen[0]) <b>_N) -}
d444e13d91ea16d54346634829ba461d
  $fMonadCodegen_$cfail :: GHC.Base.String -> CodeGen.Codegen a
  {- Arity: 2, Strictness: <B,U><B,A>x,
     Unfolding: InlineRule (0, True, True)
                (CodeGen.$fMonadCodegen_$s$fMonadStateT_$cfail
                   @ CodeGen.CodegenState)
                  `cast`
                (forall (a :: <*>_N).
                 <[GHC.Types.Char]>_R ->_R Sym (CodeGen.N:Codegen[0]) <a>_N) -}
d444e13d91ea16d54346634829ba461d
  $fMonadCodegen_$creturn :: a -> CodeGen.Codegen a
  {- Arity: 2, HasNoCafRefs, Strictness: <L,U><L,U>m,
     Unfolding: InlineRule (0, True, True)
                (\ @ a -> GHC.Tuple.(,) @ a @ CodeGen.CodegenState)
                  `cast`
                (forall (a :: <*>_N).
                 <a>_R
                 ->_R Trans
                          (<CodeGen.CodegenState>_R
                           ->_R Sym (Data.Functor.Identity.N:Identity[0]
                                         <(a, CodeGen.CodegenState)>_R))
                          (Trans
                               (Sym (Control.Monad.Trans.State.Lazy.N:StateT[0]
                                         <CodeGen.CodegenState>_N
                                         <Data.Functor.Identity.Identity>_R
                                         <a>_N))
                               (Sym (CodeGen.N:Codegen[0]) <a>_N))) -}
e5ce8cb4aff6e707ccc408ea1ec91fc6
  $fMonadCodegen_$s$fMonadStateT_$c>> ::
    Control.Monad.Trans.State.Lazy.StateT
      s Data.Functor.Identity.Identity a
    -> Control.Monad.Trans.State.Lazy.StateT
         s Data.Functor.Identity.Identity b
    -> Control.Monad.Trans.State.Lazy.StateT
         s Data.Functor.Identity.Identity b
  {- Arity: 3, HasNoCafRefs,
     Strictness: <L,1*C1(U(A,1*U))><C(S),1*C1(U(U,U))><L,U>,
     Inline: INLINE (sat-args=2),
     Unfolding: InlineRule (2, False, False)
                (\ @ s
                   @ a
                   @ b
                   (m1 :: Control.Monad.Trans.State.Lazy.StateT
                            s Data.Functor.Identity.Identity a)
                   (k :: Control.Monad.Trans.State.Lazy.StateT
                           s Data.Functor.Identity.Identity b) ->
                 GHC.Base.$
                   @ 'GHC.Types.PtrRepLifted
                   @ (s -> Data.Functor.Identity.Identity (b, s))
                   @ (Control.Monad.Trans.State.Lazy.StateT
                        s Data.Functor.Identity.Identity b)
                   (\ (tpl :: s -> Data.Functor.Identity.Identity (b, s)) -> tpl)
                     `cast`
                   (<s -> Data.Functor.Identity.Identity (b, s)>_R
                    ->_R Sym (Control.Monad.Trans.State.Lazy.N:StateT[0]
                                  <s>_N <Data.Functor.Identity.Identity>_R <b>_N))
                   (\ (s1 :: s) ->
                    Data.Functor.Identity.$fMonadIdentity_$c>>=
                      @ (a, s)
                      @ (b, s)
                      (Control.Monad.Trans.State.Lazy.runStateT
                         @ s
                         @ Data.Functor.Identity.Identity
                         @ a
                         m1
                         s1)
                      (\ (ds :: (a, s))[OneShot] ->
                       Control.Monad.Trans.State.Lazy.runStateT
                         @ s
                         @ Data.Functor.Identity.Identity
                         @ b
                         k
                         (case ds of wild { (,) a1 s' -> s' })))) -}
2093b18801c1aa958383e91c1d894358
  $fMonadCodegen_$s$fMonadStateT_$c>>= ::
    Control.Monad.Trans.State.Lazy.StateT
      s Data.Functor.Identity.Identity a
    -> (a
        -> Control.Monad.Trans.State.Lazy.StateT
             s Data.Functor.Identity.Identity b)
    -> Control.Monad.Trans.State.Lazy.StateT
         s Data.Functor.Identity.Identity b
  {- Arity: 3, HasNoCafRefs,
     Strictness: <L,1*C1(U(U,U))><C(C(S)),1*C1(C1(U(U,U)))><L,U>,
     Inline: INLINE (sat-args=2),
     Unfolding: InlineRule (2, False, False)
                (\ @ s
                   @ a
                   @ b
                   (m1 :: Control.Monad.Trans.State.Lazy.StateT
                            s Data.Functor.Identity.Identity a)
                   (k :: a
                         -> Control.Monad.Trans.State.Lazy.StateT
                              s Data.Functor.Identity.Identity b) ->
                 GHC.Base.$
                   @ 'GHC.Types.PtrRepLifted
                   @ (s -> Data.Functor.Identity.Identity (b, s))
                   @ (Control.Monad.Trans.State.Lazy.StateT
                        s Data.Functor.Identity.Identity b)
                   (\ (tpl :: s -> Data.Functor.Identity.Identity (b, s)) -> tpl)
                     `cast`
                   (<s -> Data.Functor.Identity.Identity (b, s)>_R
                    ->_R Sym (Control.Monad.Trans.State.Lazy.N:StateT[0]
                                  <s>_N <Data.Functor.Identity.Identity>_R <b>_N))
                   (\ (s1 :: s) ->
                    Data.Functor.Identity.$fMonadIdentity_$c>>=
                      @ (a, s)
                      @ (b, s)
                      (Control.Monad.Trans.State.Lazy.runStateT
                         @ s
                         @ Data.Functor.Identity.Identity
                         @ a
                         m1
                         s1)
                      (\ (ds :: (a, s))[OneShot] ->
                       Control.Monad.Trans.State.Lazy.runStateT
                         @ s
                         @ Data.Functor.Identity.Identity
                         @ b
                         (k (case ds of wild { (,) a1 s' -> a1 }))
                         (case ds of wild { (,) a1 s' -> s' })))) -}
dea801621c52179d150eab9c66759255
  $fMonadCodegen_$s$fMonadStateT_$cfail ::
    GHC.Base.String
    -> Control.Monad.Trans.State.Lazy.StateT
         s Data.Functor.Identity.Identity a
  {- Arity: 2, Strictness: <B,U><B,A>x, Inline: INLINE (sat-args=1),
     Unfolding: InlineRule (1, False, False)
                (\ @ s @ a (str :: GHC.Base.String) ->
                 GHC.Base.$
                   @ 'GHC.Types.PtrRepLifted
                   @ (s -> Data.Functor.Identity.Identity (a, s))
                   @ (Control.Monad.Trans.State.Lazy.StateT
                        s Data.Functor.Identity.Identity a)
                   (\ (tpl :: s -> Data.Functor.Identity.Identity (a, s)) -> tpl)
                     `cast`
                   (<s -> Data.Functor.Identity.Identity (a, s)>_R
                    ->_R Sym (Control.Monad.Trans.State.Lazy.N:StateT[0]
                                  <s>_N <Data.Functor.Identity.Identity>_R <a>_N))
                   (\ (ds :: s) ->
                    Data.Functor.Identity.$fMonadIdentity_$s$dmfail @ (a, s) str)) -}
1d1e1a70335092265202f3dd4938f3fb
  $fMonadLLVM :: GHC.Base.Monad CodeGen.LLVM
  DFunId
  {- Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ CodeGen.LLVM
                  CodeGen.$fApplicativeLLVM
                  CodeGen.$fMonadLLVM_$c>>=
                  CodeGen.$fMonadLLVM_$c>>
                  CodeGen.$fMonadLLVM_$creturn
                  CodeGen.$fMonadLLVM_$cfail -}
1d1e1a70335092265202f3dd4938f3fb
  $fMonadLLVM_$c>> ::
    CodeGen.LLVM a -> CodeGen.LLVM b -> CodeGen.LLVM b
  {- Arity: 3, HasNoCafRefs,
     Strictness: <L,1*C1(U(A,1*U))><C(S),1*C1(U(U,U))><L,U>,
     Unfolding: InlineRule (0, True, True)
                (CodeGen.$fMonadCodegen_$s$fMonadStateT_$c>> @ LLVM.AST.Module)
                  `cast`
                (forall (a :: <*>_N) (b :: <*>_N).
                 Sym (CodeGen.N:LLVM[0]) <a>_N
                 ->_R Sym (CodeGen.N:LLVM[0]) <b>_N
                 ->_R Sym (CodeGen.N:LLVM[0]) <b>_N) -}
1d1e1a70335092265202f3dd4938f3fb
  $fMonadLLVM_$c>>= ::
    CodeGen.LLVM a -> (a -> CodeGen.LLVM b) -> CodeGen.LLVM b
  {- Arity: 3, HasNoCafRefs,
     Strictness: <L,1*C1(U(U,U))><C(C(S)),1*C1(C1(U(U,U)))><L,U>,
     Unfolding: InlineRule (0, True, True)
                (CodeGen.$fMonadCodegen_$s$fMonadStateT_$c>>= @ LLVM.AST.Module)
                  `cast`
                (forall (a :: <*>_N) (b :: <*>_N).
                 Sym (CodeGen.N:LLVM[0]) <a>_N
                 ->_R (<a>_R ->_R Sym (CodeGen.N:LLVM[0]) <b>_N)
                 ->_R Sym (CodeGen.N:LLVM[0]) <b>_N) -}
1d1e1a70335092265202f3dd4938f3fb
  $fMonadLLVM_$cfail :: GHC.Base.String -> CodeGen.LLVM a
  {- Arity: 2, Strictness: <B,U><B,A>x,
     Unfolding: InlineRule (0, True, True)
                (CodeGen.$fMonadCodegen_$s$fMonadStateT_$cfail @ LLVM.AST.Module)
                  `cast`
                (forall (a :: <*>_N).
                 <[GHC.Types.Char]>_R ->_R Sym (CodeGen.N:LLVM[0]) <a>_N) -}
1d1e1a70335092265202f3dd4938f3fb
  $fMonadLLVM_$creturn :: a -> CodeGen.LLVM a
  {- Arity: 2, HasNoCafRefs, Strictness: <L,U><L,U>m,
     Unfolding: InlineRule (0, True, True)
                (\ @ a -> GHC.Tuple.(,) @ a @ LLVM.AST.Module)
                  `cast`
                (forall (a :: <*>_N).
                 <a>_R
                 ->_R Trans
                          (<LLVM.AST.Module>_R
                           ->_R Sym (Data.Functor.Identity.N:Identity[0]
                                         <(a, LLVM.AST.Module)>_R))
                          (Trans
                               (Sym (Control.Monad.Trans.State.Lazy.N:StateT[0]
                                         <LLVM.AST.Module>_N
                                         <Data.Functor.Identity.Identity>_R
                                         <a>_N))
                               (Sym (CodeGen.N:LLVM[0]) <a>_N))) -}
d444e13d91ea16d54346634829ba461d
  $fMonadStateCodegen ::
    Control.Monad.State.Class.MonadState
      CodeGen.CodegenState CodeGen.Codegen
  DFunId
  {- Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ CodeGen.CodegenState
                  @ CodeGen.Codegen
                  CodeGen.$fMonadCodegen
                  CodeGen.$fMonadStateCodegen_$cget
                  CodeGen.$fMonadStateCodegen_$cput
                  CodeGen.$fMonadStateCodegen_$cstate -}
da6e15195d442835a8689242cb5824f2
  $fMonadStateCodegen1 ::
    (CodeGen.CodegenState -> (a, CodeGen.CodegenState))
    -> CodeGen.CodegenState -> (a, CodeGen.CodegenState)
  {- Arity: 2, HasNoCafRefs, Strictness: <C(S),1*C1(U(U,U))><L,U>,
     Unfolding: InlineRule (2, True, True)
                (\ @ a
                   (eta :: CodeGen.CodegenState -> (a, CodeGen.CodegenState))
                   (eta1 :: CodeGen.CodegenState) ->
                 eta eta1) -}
bcb067a87ed68e47ab6ae3bff963e8a6
  $fMonadStateCodegen2 ::
    CodeGen.CodegenState
    -> (CodeGen.CodegenState, CodeGen.CodegenState)
  {- Arity: 1, HasNoCafRefs, Strictness: <L,U>m,
     Unfolding: InlineRule (1, True, False)
                (\ (eta :: CodeGen.CodegenState) -> (eta, eta)) -}
d444e13d91ea16d54346634829ba461d
  $fMonadStateCodegen_$cget :: CodeGen.Codegen CodeGen.CodegenState
  {- Arity: 1, HasNoCafRefs, Strictness: <L,U>m,
     Unfolding: InlineRule (0, True, True)
                CodeGen.$fMonadStateCodegen2
                  `cast`
                (Trans
                     (<CodeGen.CodegenState>_R
                      ->_R Sym (Data.Functor.Identity.N:Identity[0]
                                    <(CodeGen.CodegenState, CodeGen.CodegenState)>_R))
                     (Trans
                          (Sym (Control.Monad.Trans.State.Lazy.N:StateT[0]
                                    <CodeGen.CodegenState>_N
                                    <Data.Functor.Identity.Identity>_R
                                    <CodeGen.CodegenState>_N))
                          (Sym (CodeGen.N:Codegen[0]) <CodeGen.CodegenState>_N))) -}
d444e13d91ea16d54346634829ba461d
  $fMonadStateCodegen_$cput ::
    CodeGen.CodegenState -> CodeGen.Codegen ()
  {- Arity: 2, HasNoCafRefs, Strictness: <L,U><L,A>m,
     Unfolding: InlineRule (0, True, True)
                (CodeGen.$fMonadStateCodegen_$sput @ CodeGen.CodegenState)
                  `cast`
                (<CodeGen.CodegenState>_R
                 ->_R Sym (CodeGen.N:Codegen[0]) <()>_N) -}
d444e13d91ea16d54346634829ba461d
  $fMonadStateCodegen_$cstate ::
    (CodeGen.CodegenState -> (a, CodeGen.CodegenState))
    -> CodeGen.Codegen a
  {- Arity: 2, HasNoCafRefs, Strictness: <C(S),1*C1(U(U,U))><L,U>,
     Unfolding: InlineRule (0, True, True)
                CodeGen.$fMonadStateCodegen1
                  `cast`
                (forall (a :: <*>_N).
                 <CodeGen.CodegenState -> (a, CodeGen.CodegenState)>_R
                 ->_R Trans
                          (<CodeGen.CodegenState>_R
                           ->_R Sym (Data.Functor.Identity.N:Identity[0]
                                         <(a, CodeGen.CodegenState)>_R))
                          (Trans
                               (Sym (Control.Monad.Trans.State.Lazy.N:StateT[0]
                                         <CodeGen.CodegenState>_N
                                         <Data.Functor.Identity.Identity>_R
                                         <a>_N))
                               (Sym (CodeGen.N:Codegen[0]) <a>_N))) -}
cb15be3b1a8282e7c56f0970512fe290
  $fMonadStateCodegen_$sput ::
    s
    -> Control.Monad.Trans.State.Lazy.StateT
         s Data.Functor.Identity.Identity ()
  {- Arity: 2, HasNoCafRefs, Strictness: <L,U><L,A>m,
     Inline: INLINE (sat-args=1),
     Unfolding: InlineRule (1, False, False)
                (\ @ s (s1 :: s) ->
                 GHC.Base.$
                   @ 'GHC.Types.PtrRepLifted
                   @ (s -> ((), s))
                   @ (Control.Monad.Trans.State.Lazy.StateT
                        s Data.Functor.Identity.Identity ())
                   (Control.Monad.Trans.State.Lazy.state
                      @ Data.Functor.Identity.Identity
                      @ s
                      @ ()
                      Data.Functor.Identity.$fMonadIdentity)
                   (\ (ds :: s) -> (GHC.Tuple.(), s1))) -}
1d1e1a70335092265202f3dd4938f3fb
  $fMonadStateLLVM ::
    Control.Monad.State.Class.MonadState LLVM.AST.Module CodeGen.LLVM
  DFunId
  {- Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ LLVM.AST.Module
                  @ CodeGen.LLVM
                  CodeGen.$fMonadLLVM
                  CodeGen.$fMonadStateLLVM_$cget
                  CodeGen.$fMonadStateLLVM_$cput
                  CodeGen.$fMonadStateLLVM_$cstate -}
77d7f010a984fcda327d59fc56984dfb
  $fMonadStateLLVM1 ::
    (LLVM.AST.Module -> (a, LLVM.AST.Module))
    -> LLVM.AST.Module -> (a, LLVM.AST.Module)
  {- Arity: 2, HasNoCafRefs, Strictness: <C(S),1*C1(U(U,U))><L,U>,
     Unfolding: InlineRule (2, True, True)
                (\ @ a
                   (eta :: LLVM.AST.Module -> (a, LLVM.AST.Module))
                   (eta1 :: LLVM.AST.Module) ->
                 eta eta1) -}
45fd6a2e4333b4a7c8d6e9180cd68f8c
  $fMonadStateLLVM2 ::
    LLVM.AST.Module -> (LLVM.AST.Module, LLVM.AST.Module)
  {- Arity: 1, HasNoCafRefs, Strictness: <L,U>m,
     Unfolding: InlineRule (1, True, False)
                (\ (eta :: LLVM.AST.Module) -> (eta, eta)) -}
1d1e1a70335092265202f3dd4938f3fb
  $fMonadStateLLVM_$cget :: CodeGen.LLVM LLVM.AST.Module
  {- Arity: 1, HasNoCafRefs, Strictness: <L,U>m,
     Unfolding: InlineRule (0, True, True)
                CodeGen.$fMonadStateLLVM2
                  `cast`
                (Trans
                     (<LLVM.AST.Module>_R
                      ->_R Sym (Data.Functor.Identity.N:Identity[0]
                                    <(LLVM.AST.Module, LLVM.AST.Module)>_R))
                     (Trans
                          (Sym (Control.Monad.Trans.State.Lazy.N:StateT[0]
                                    <LLVM.AST.Module>_N
                                    <Data.Functor.Identity.Identity>_R
                                    <LLVM.AST.Module>_N))
                          (Sym (CodeGen.N:LLVM[0]) <LLVM.AST.Module>_N))) -}
1d1e1a70335092265202f3dd4938f3fb
  $fMonadStateLLVM_$cput :: LLVM.AST.Module -> CodeGen.LLVM ()
  {- Arity: 2, HasNoCafRefs, Strictness: <L,U><L,A>m,
     Unfolding: InlineRule (0, True, True)
                (CodeGen.$fMonadStateCodegen_$sput @ LLVM.AST.Module)
                  `cast`
                (<LLVM.AST.Module>_R ->_R Sym (CodeGen.N:LLVM[0]) <()>_N) -}
1d1e1a70335092265202f3dd4938f3fb
  $fMonadStateLLVM_$cstate ::
    (LLVM.AST.Module -> (a, LLVM.AST.Module)) -> CodeGen.LLVM a
  {- Arity: 2, HasNoCafRefs, Strictness: <C(S),1*C1(U(U,U))><L,U>,
     Unfolding: InlineRule (0, True, True)
                CodeGen.$fMonadStateLLVM1
                  `cast`
                (forall (a :: <*>_N).
                 <LLVM.AST.Module -> (a, LLVM.AST.Module)>_R
                 ->_R Trans
                          (<LLVM.AST.Module>_R
                           ->_R Sym (Data.Functor.Identity.N:Identity[0]
                                         <(a, LLVM.AST.Module)>_R))
                          (Trans
                               (Sym (Control.Monad.Trans.State.Lazy.N:StateT[0]
                                         <LLVM.AST.Module>_N
                                         <Data.Functor.Identity.Identity>_R
                                         <a>_N))
                               (Sym (CodeGen.N:LLVM[0]) <a>_N))) -}
6a62766a2d9040ce50a204668728fe6b
  $fShowBlockState :: GHC.Show.Show CodeGen.BlockState
  DFunId
  {- Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ CodeGen.BlockState
                  CodeGen.$fShowBlockState_$cshowsPrec
                  CodeGen.$fShowBlockState_$cshow
                  CodeGen.$fShowBlockState_$cshowList -}
6a62766a2d9040ce50a204668728fe6b
  $fShowBlockState1 :: CodeGen.BlockState -> GHC.Show.ShowS
  {- Arity: 1,
     Unfolding: (\ (w :: CodeGen.BlockState) ->
                 case w of ww { CodeGen.BlockState ww1 ww2 ww3 ->
                 CodeGen.$w$cshowsPrec 0# ww1 ww2 ww3 }) -}
6a62766a2d9040ce50a204668728fe6b
  $fShowBlockState_$cshow :: CodeGen.BlockState -> GHC.Base.String
  {- Arity: 1, Strictness: <S,1*U(U(U),U,1*U)>,
     Unfolding: InlineRule (1, True, False)
                (\ (x :: CodeGen.BlockState) ->
                 CodeGen.$fShowBlockState_$cshowsPrec
                   GHC.Show.shows22
                   x
                   (GHC.Types.[] @ GHC.Types.Char)) -}
6a62766a2d9040ce50a204668728fe6b
  $fShowBlockState_$cshowList ::
    [CodeGen.BlockState] -> GHC.Show.ShowS
  {- Arity: 2,
     Unfolding: (GHC.Show.showList__
                   @ CodeGen.BlockState
                   CodeGen.$fShowBlockState1) -}
6a62766a2d9040ce50a204668728fe6b
  $fShowBlockState_$cshowsPrec ::
    GHC.Types.Int -> CodeGen.BlockState -> GHC.Show.ShowS
  {- Arity: 2, Strictness: <S(S),1*U(U)><S,1*U(U(U),U,1*U)>,
     Inline: INLINE[0],
     Unfolding: InlineRule (2, True, False)
                (\ (w :: GHC.Types.Int) (w1 :: CodeGen.BlockState) ->
                 case w of ww { GHC.Types.I# ww1 ->
                 case w1 of ww2 { CodeGen.BlockState ww3 ww4 ww5 ->
                 CodeGen.$w$cshowsPrec ww1 ww3 ww4 ww5 } }) -}
ebdea5f4c416b00304df054966adeab3
  $fShowCodegenState :: GHC.Show.Show CodeGen.CodegenState
  DFunId
  {- Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ CodeGen.CodegenState
                  CodeGen.$fShowCodegenState_$cshowsPrec
                  CodeGen.$fShowCodegenState_$cshow
                  CodeGen.$fShowCodegenState_$cshowList -}
ebdea5f4c416b00304df054966adeab3
  $fShowCodegenState1 :: CodeGen.CodegenState -> GHC.Show.ShowS
  {- Arity: 1,
     Unfolding: (\ (w :: CodeGen.CodegenState) ->
                 case w of ww { CodeGen.CodegenState ww1 ww2 ww3 ww4 ww5 ww6 ->
                 CodeGen.$w$cshowsPrec1 0# ww1 ww2 ww3 ww4 ww5 ww6 }) -}
ebdea5f4c416b00304df054966adeab3
  $fShowCodegenState_$cshow ::
    CodeGen.CodegenState -> GHC.Base.String
  {- Arity: 1, Strictness: <S,1*U(U,1*U,U,U(U),U(U),1*U)>,
     Unfolding: InlineRule (1, True, False)
                (\ (x :: CodeGen.CodegenState) ->
                 CodeGen.$fShowCodegenState_$cshowsPrec
                   GHC.Show.shows22
                   x
                   (GHC.Types.[] @ GHC.Types.Char)) -}
ebdea5f4c416b00304df054966adeab3
  $fShowCodegenState_$cshowList ::
    [CodeGen.CodegenState] -> GHC.Show.ShowS
  {- Arity: 2,
     Unfolding: (GHC.Show.showList__
                   @ CodeGen.CodegenState
                   CodeGen.$fShowCodegenState1) -}
ebdea5f4c416b00304df054966adeab3
  $fShowCodegenState_$cshowsPrec ::
    GHC.Types.Int -> CodeGen.CodegenState -> GHC.Show.ShowS
  {- Arity: 2,
     Strictness: <S(S),1*U(U)><S,1*U(U,1*U,U,U(U),U(U),1*U)>,
     Inline: INLINE[0],
     Unfolding: InlineRule (2, True, False)
                (\ (w :: GHC.Types.Int) (w1 :: CodeGen.CodegenState) ->
                 case w of ww { GHC.Types.I# ww1 ->
                 case w1 of ww2 { CodeGen.CodegenState ww3 ww4 ww5 ww6 ww7 ww8 ->
                 CodeGen.$w$cshowsPrec1 ww1 ww3 ww4 ww5 ww6 ww7 ww8 } }) -}
a30d6918be58fb308f0ad75e0b3e2633
  $s$fShowNamed ::
    GHC.Show.Show
      (LLVM.AST.Instruction.Named LLVM.AST.Instruction.Terminator)
  {- Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ (LLVM.AST.Instruction.Named LLVM.AST.Instruction.Terminator)
                  (LLVM.AST.Instruction.$fShowNamed_$cshowsPrec
                     @ LLVM.AST.Instruction.Terminator
                     LLVM.AST.Instruction.$fShowTerminator)
                  (LLVM.AST.Instruction.$fShowNamed_$cshow
                     @ LLVM.AST.Instruction.Terminator
                     LLVM.AST.Instruction.$fShowTerminator)
                  CodeGen.$s$fShowNamed_$s$fShowNamed_$cshowList -}
6e1ea37a888a806dbd0f790e61bc8770
  $s$fShowNamed_$s$fShowNamed_$cshowList ::
    [LLVM.AST.Instruction.Named LLVM.AST.Instruction.Terminator]
    -> GHC.Show.ShowS
  {- Arity: 2, Strictness: <S,1*U><L,U>,
     Unfolding: InlineRule (2, True, False)
                (\ (eta :: [LLVM.AST.Instruction.Named
                              LLVM.AST.Instruction.Terminator])
                   (eta1 :: GHC.Base.String) ->
                 GHC.Show.showList__
                   @ (LLVM.AST.Instruction.Named LLVM.AST.Instruction.Terminator)
                   (LLVM.AST.Instruction.$fShowNamed_$cshowsPrec
                      @ LLVM.AST.Instruction.Terminator
                      LLVM.AST.Instruction.$fShowTerminator
                      LLVM.AST.Instruction.$fDataInstruction2)
                   eta
                   eta1) -}
1d0962360242c1d749f9c2df929162ef
  $sinsert_$sgo1 ::
    LLVM.AST.Name.Name
    -> a1
    -> Data.Map.Base.Map LLVM.AST.Name.Name a1
    -> Data.Map.Base.Map LLVM.AST.Name.Name a1
  {- Arity: 3, Strictness: <S,1*U><L,U><S,1*U> -}
9310df921aebf30860d4c30e0c44b82e
  $sinsert_$sgo10 ::
    GHC.Base.String
    -> a1
    -> Data.Map.Base.Map GHC.Base.String a1
    -> Data.Map.Base.Map GHC.Base.String a1
  {- Arity: 3, Strictness: <S,1*U><L,U><S,1*U> -}
55c6b6e336ab2b7db8c762d08a56cae7
  $slookup1 ::
    GHC.Base.String
    -> Data.Map.Base.Map GHC.Base.String a -> GHC.Base.Maybe a
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,1*U> -}
be8af4fa1d9e3a8e411f408fd600ea8c
  $slookup3 ::
    LLVM.AST.Name.Name
    -> Data.Map.Base.Map LLVM.AST.Name.Name a -> GHC.Base.Maybe a
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,1*U> -}
cfb7af83d7bdaea3db296715c0bb67b4
  $tc'BlockState :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   17152275788868856994##
                   13955453188573408933##
                   CodeGen.$trModule
                   CodeGen.$tc'BlockState1) -}
3dd4edc2b895c0accbc24d41b98daf94
  $tc'BlockState1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS "'BlockState"#) -}
1034bd93ac885e59fc587aeba1bdf1d3
  $tc'Codegen :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   14178224460106395604##
                   10929372489330308906##
                   CodeGen.$trModule
                   CodeGen.$tc'Codegen1) -}
08e324dad5b32b2ce2e4306e92bb736e
  $tc'Codegen1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS "'Codegen"#) -}
5f550ee30ccf90c110f4ca858153efab
  $tc'CodegenState :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   7227969828864165691##
                   16387399225563066085##
                   CodeGen.$trModule
                   CodeGen.$tc'CodegenState1) -}
37e07a33ea40b8214ace7297bee4caa2
  $tc'CodegenState1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS "'CodegenState"#) -}
d039fca1093e80e5147defeeef869dfd
  $tc'LLVM :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   2451338540244345484##
                   7546531243233112370##
                   CodeGen.$trModule
                   CodeGen.$tc'LLVM1) -}
1f74a5b1e754cdb9cb96f5537ce26337
  $tc'LLVM1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS "'LLVM"#) -}
6994d75f937986bb8ef89b959e589de3
  $tcBlockState :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   13216639609756966931##
                   1911399769169632234##
                   CodeGen.$trModule
                   CodeGen.$tcBlockState1) -}
f1b9328d412ae14232ecf9e51682645d
  $tcBlockState1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS "BlockState"#) -}
5bc32db7cd69c49c98afe910d1075ac5
  $tcCodegen :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   12499167097316309031##
                   11105647480885918041##
                   CodeGen.$trModule
                   CodeGen.$tcCodegen1) -}
60eaab05db973237adada2ab4a3d88ed
  $tcCodegen1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS "Codegen"#) -}
d3e5cb1eb3de3b65d31617a2e5962eb0
  $tcCodegenState :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   14551563107857433296##
                   6249386965418758113##
                   CodeGen.$trModule
                   CodeGen.$tcCodegenState1) -}
362ed6cd35c4078a7505ddc3027b30f5
  $tcCodegenState1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS "CodegenState"#) -}
ed5efc64cc36fb02880ab369d38a6d64
  $tcLLVM :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   16154922602484293565##
                   50479142353102066##
                   CodeGen.$trModule
                   CodeGen.$tcLLVM1) -}
d6666ae10cf79e77889bccc3b2d34da5
  $tcLLVM1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS "LLVM"#) -}
2146a2dbe590d74ade4b9e2a6a0523bd
  $trModule :: GHC.Types.Module
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.Module
                   CodeGen.$trModule2
                   CodeGen.$trModule1) -}
723ded1cb1f9049d117c8bbee734076f
  $trModule1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS "CodeGen"#) -}
a02707c59f7635bbfe996215305759de
  $trModule2 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS
                   "Haskull-0.1.0.0-BWrHz1hBGVfKvAfsCTzyaC"#) -}
29717df987983ef246ac5fff3705cf3f
  $w$cshowsPrec ::
    GHC.Prim.Int#
    -> GHC.Types.Int
    -> [LLVM.AST.Instruction.Named LLVM.AST.Instruction.Instruction]
    -> GHC.Base.Maybe
         (LLVM.AST.Instruction.Named LLVM.AST.Instruction.Terminator)
    -> GHC.Show.ShowS
  {- Arity: 4, Strictness: <S,U><L,U(U)><L,U><L,1*U>, Inline: [0] -}
1b0840e6f4317152ffb47d46ba29c436
  $w$cshowsPrec1 ::
    GHC.Prim.Int#
    -> LLVM.AST.Name.Name
    -> Data.Map.Base.Map LLVM.AST.Name.Name CodeGen.BlockState
    -> CodeGen.SymbolTable
    -> GHC.Types.Int
    -> GHC.Types.Word
    -> CodeGen.Names
    -> GHC.Show.ShowS
  {- Arity: 7,
     Strictness: <S,U><L,U><L,1*U><L,U><L,U(U)><L,U(U)><L,1*U>,
     Inline: [0] -}
36a9cfb082532251a5b435cab9b3e663
  $wcreateBlocks ::
    Data.Map.Base.Map LLVM.AST.Name.Name CodeGen.BlockState
    -> [LLVM.AST.Global.BasicBlock]
  {- Arity: 1, Strictness: <S,1*U>, Inline: [0],
     Unfolding: (\ (ww :: Data.Map.Base.Map
                            LLVM.AST.Name.Name CodeGen.BlockState) ->
                 GHC.Base.map
                   @ (LLVM.AST.Name.Name, CodeGen.BlockState)
                   @ LLVM.AST.Global.BasicBlock
                   CodeGen.makeBlock
                   (Data.OldList.sortBy
                      @ (LLVM.AST.Name.Name, CodeGen.BlockState)
                      CodeGen.createBlocks1
                      (Data.Map.Base.toAscList1
                         @ LLVM.AST.Name.Name
                         @ CodeGen.BlockState
                         (GHC.Types.[] @ (LLVM.AST.Name.Name, CodeGen.BlockState))
                         ww))) -}
b28210f16726adbc9e97d2242e2e741b
  $winstr ::
    LLVM.AST.Instruction.Instruction
    -> CodeGen.CodegenState
    -> (# LLVM.AST.Operand.Operand, CodeGen.CodegenState #)
  {- Arity: 2, Strictness: <L,U><L,U(U,U,U,U,1*U(U),U)>, Inline: [0],
     Unfolding: (\ (w :: LLVM.AST.Instruction.Instruction)
                   (w1 :: CodeGen.CodegenState) ->
                 let {
                   i :: GHC.Types.Word
                   = case w1 of wild { CodeGen.CodegenState ds ds1 ds2 ds3 ds4 ds5 ->
                     ds4 }
                 } in
                 let {
                   ds :: GHC.Types.Word
                   = case i of wild { GHC.Types.W# x# ->
                     GHC.Types.W# (GHC.Prim.plusWord# x# 1##) }
                 } in
                 let {
                   ref :: LLVM.AST.Name.Name = LLVM.AST.Name.UnName ds
                 } in
                 (# LLVM.AST.Operand.LocalReference LLVM.AST.Type.double ref,
                    case w1 of wild { CodeGen.CodegenState ds1 ds2 ds3 ds4 ds5 ds6 ->
                    case CodeGen.$slookup3 @ CodeGen.BlockState ds1 ds2 of wild1 {
                      GHC.Base.Nothing
                      -> case CodeGen.alloca4 ds1 ret_ty CodeGen.CodegenState of {}
                      GHC.Base.Just x
                      -> CodeGen.CodegenState
                           ds1
                           (CodeGen.$sinsert_$sgo1
                              @ CodeGen.BlockState
                              ds1
                              (case x of wild2 { CodeGen.BlockState ds7 ds8 ds9 ->
                               CodeGen.BlockState
                                 ds7
                                 (GHC.Types.:
                                    @ (LLVM.AST.Instruction.Named LLVM.AST.Instruction.Instruction)
                                    (LLVM.AST.Instruction.:=
                                       @ LLVM.AST.Instruction.Instruction
                                       ref
                                       w)
                                    ds8)
                                 ds9 })
                              ds2)
                           ds3
                           ds4
                           (case i of wild2 { GHC.Types.W# y# ->
                            GHC.Types.W# (GHC.Prim.plusWord# 1## y#) })
                           ds6 } } #)) -}
a09bbc243faf979098c7815243a19f19
  $wterminator ::
    LLVM.AST.Instruction.Named LLVM.AST.Instruction.Terminator
    -> CodeGen.CodegenState
    -> (# LLVM.AST.Instruction.Named LLVM.AST.Instruction.Terminator,
          CodeGen.CodegenState #)
  {- Arity: 2, Strictness: <L,U><L,U(U,U,U,U,U,U)>, Inline: [0],
     Unfolding: (\ (w :: LLVM.AST.Instruction.Named
                           LLVM.AST.Instruction.Terminator)
                   (w1 :: CodeGen.CodegenState) ->
                 (# w,
                    case w1 of wild { CodeGen.CodegenState ds ds1 ds2 ds3 ds4 ds5 ->
                    case CodeGen.$slookup3 @ CodeGen.BlockState ds ds1 of wild1 {
                      GHC.Base.Nothing
                      -> case CodeGen.alloca4 ds ret_ty CodeGen.CodegenState of {}
                      GHC.Base.Just x
                      -> CodeGen.CodegenState
                           ds
                           (CodeGen.$sinsert_$sgo1
                              @ CodeGen.BlockState
                              ds
                              (case x of wild2 { CodeGen.BlockState ds6 ds7 ds8 ->
                               CodeGen.BlockState
                                 ds6
                                 ds7
                                 (GHC.Base.Just
                                    @ (LLVM.AST.Instruction.Named LLVM.AST.Instruction.Terminator)
                                    w) })
                              ds1)
                           ds2
                           ds3
                           ds4
                           ds5 } } #)) -}
fa374b079915e622c7de1ed71453029e
  $wunikName ::
    GHC.Base.String
    -> CodeGen.Names -> (# GHC.Base.String, CodeGen.Names #)
  {- Arity: 2, Strictness: <S,U><S,U>, Inline: [0],
     Unfolding: (\ (w :: GHC.Base.String) (w1 :: CodeGen.Names) ->
                 case CodeGen.$slookup1 @ GHC.Types.Int w w1 of wild {
                   GHC.Base.Nothing
                   -> (# w,
                         CodeGen.$sinsert_$sgo10
                           @ GHC.Types.Int
                           w
                           CodeGen.emptyCodegen2
                           w1 #)
                   GHC.Base.Just idx1
                   -> (# GHC.Base.++
                           @ GHC.Types.Char
                           w
                           (case idx1 of ww2 { GHC.Types.I# ww3 ->
                            case GHC.Show.$wshowSignedInt
                                   0#
                                   ww3
                                   (GHC.Types.[] @ GHC.Types.Char) of ww4 { (#,#) ww5 ww6 ->
                            GHC.Types.: @ GHC.Types.Char ww5 ww6 } }),
                         CodeGen.$sinsert_$sgo10
                           @ GHC.Types.Int
                           w
                           (case idx1 of wild1 { GHC.Types.I# x ->
                            GHC.Types.I# (GHC.Prim.+# x 1#) })
                           w1 #) }) -}
6a62766a2d9040ce50a204668728fe6b
  data BlockState
    = BlockState {idx :: GHC.Types.Int,
                  stack :: [LLVM.AST.Instruction.Named
                              LLVM.AST.Instruction.Instruction],
                  term :: GHC.Base.Maybe
                            (LLVM.AST.Instruction.Named LLVM.AST.Instruction.Terminator)}
d444e13d91ea16d54346634829ba461d
  type role Codegen nominal
  newtype Codegen a
    = Codegen {runCodegen :: Control.Monad.Trans.State.Lazy.State
                               CodeGen.CodegenState a}
ebdea5f4c416b00304df054966adeab3
  data CodegenState
    = CodegenState {currentBlock :: LLVM.AST.Name.Name,
                    blocks :: Data.Map.Base.Map LLVM.AST.Name.Name CodeGen.BlockState,
                    symtab :: CodeGen.SymbolTable,
                    blockCount :: GHC.Types.Int,
                    count :: GHC.Types.Word,
                    names :: CodeGen.Names}
1d1e1a70335092265202f3dd4938f3fb
  type role LLVM nominal
  newtype LLVM a
    = LLVM (Control.Monad.Trans.State.Lazy.State LLVM.AST.Module a)
468494d039fa7bf1a0bdd632a10d6f51
  type Names = Data.Map.Base.Map GHC.Base.String GHC.Types.Int
ab15dc75287589b01fe88017d4ed967b
  type SymbolTable = [(GHC.Base.String, LLVM.AST.Operand.Operand)]
b70b67b14fe5133cfed95a961feb073b
  addDef :: LLVM.AST.Definition -> CodeGen.LLVM ()
  {- Arity: 2, HasNoCafRefs, Strictness: <L,U><L,1*U(U,U,U,U,U)>m,
     Unfolding: InlineRule (0, True, True)
                CodeGen.addDef1
                  `cast`
                (<LLVM.AST.Definition>_R
                 ->_R Trans
                          (<LLVM.AST.Module>_R
                           ->_R Sym (Data.Functor.Identity.N:Identity[0]
                                         <((), LLVM.AST.Module)>_R))
                          (Trans
                               (Sym (Control.Monad.Trans.State.Lazy.N:StateT[0]
                                         <LLVM.AST.Module>_N
                                         <Data.Functor.Identity.Identity>_R
                                         <()>_N))
                               (Sym (CodeGen.N:LLVM[0]) <()>_N))) -}
59fa501480d698048674f9fd50e903b6
  addDef1 ::
    LLVM.AST.Definition -> LLVM.AST.Module -> ((), LLVM.AST.Module)
  {- Arity: 2, HasNoCafRefs, Strictness: <L,U><L,1*U(U,U,U,U,U)>m,
     Unfolding: InlineRule (2, True, False)
                (\ (def :: LLVM.AST.Definition) (eta :: LLVM.AST.Module) ->
                 (GHC.Tuple.(),
                  case eta of wild { LLVM.AST.Module ds ds1 ds2 ds3 ds4 ->
                  LLVM.AST.Module
                    ds
                    ds1
                    ds2
                    ds3
                    (GHC.Types.: @ LLVM.AST.Definition def ds4) })) -}
7a09c70bb1bc332075a0836044408925
  alloca ::
    LLVM.AST.Type.Type -> CodeGen.Codegen LLVM.AST.Operand.Operand
  {- Arity: 2, Strictness: <L,U><L,U(U,U,U,U,U(U),U)>m,
     Unfolding: InlineRule (0, True, True)
                CodeGen.alloca1
                  `cast`
                (<LLVM.AST.Type.Type>_R
                 ->_R Trans
                          (Sym (Control.Monad.Trans.State.Lazy.N:StateT[0]
                                    <CodeGen.CodegenState>_N
                                    <Data.Functor.Identity.Identity>_R
                                    <LLVM.AST.Operand.Operand>_N))
                          (Sym (CodeGen.N:Codegen[0]) <LLVM.AST.Operand.Operand>_N)) -}
80c2a14e1c2dc6a3708e0d3a2a917250
  alloca1 ::
    LLVM.AST.Type.Type
    -> CodeGen.CodegenState
    -> Data.Functor.Identity.Identity
         (LLVM.AST.Operand.Operand, CodeGen.CodegenState)
  {- Arity: 2, Strictness: <L,U><L,U(U,U,U,U,U(U),U)>m,
     Unfolding: InlineRule (2, True, False)
                (\ (ty :: LLVM.AST.Type.Type) (eta :: CodeGen.CodegenState) ->
                 CodeGen.alloca3
                   (LLVM.AST.Instruction.Alloca
                      ty
                      (GHC.Base.Nothing @ LLVM.AST.Operand.Operand)
                      CodeGen.alloca2
                      (GHC.Types.[] @ (GHC.Base.String, LLVM.AST.Operand.MetadataNode)))
                   eta) -}
c19dab8be2be4202d89e70017c46e51a
  alloca2 :: GHC.Word.Word32
  {- HasNoCafRefs, Strictness: m, Unfolding: (GHC.Word.W32# 0##) -}
60c41d2d97d7e4e481ef5dd09ab7e8cd
  alloca3 ::
    LLVM.AST.Instruction.Instruction
    -> CodeGen.CodegenState
    -> Data.Functor.Identity.Identity
         (LLVM.AST.Operand.Operand, CodeGen.CodegenState)
  {- Arity: 2, Strictness: <L,U><L,U(U,U,U,U,1*U(U),U)>m,
     Inline: INLINE[0],
     Unfolding: InlineRule (2, True, False)
                (\ (w :: LLVM.AST.Instruction.Instruction)
                   (w1 :: CodeGen.CodegenState) ->
                 case CodeGen.$winstr w w1 of ww { (#,#) ww1 ww2 ->
                 (ww1, ww2)
                   `cast`
                 (Sym (Data.Functor.Identity.N:Identity[0]
                           <(LLVM.AST.Operand.Operand, CodeGen.CodegenState)>_R)) }) -}
6c081786a5644e1cc4dbf00ab0306792
  alloca4 :: LLVM.AST.Name.Name -> CodeGen.Codegen CodeGen.BlockState
  {- Arity: 1, Strictness: <L,U>x -}
d953215e24497d3da11c4b1927858874
  assign ::
    GHC.Base.String -> LLVM.AST.Operand.Operand -> CodeGen.Codegen ()
  {- Arity: 3, HasNoCafRefs,
     Strictness: <L,U><L,U><L,1*U(U,U,U,U,U,U)>m,
     Unfolding: InlineRule (0, True, True)
                CodeGen.assign1
                  `cast`
                (<GHC.Base.String>_R
                 ->_R <LLVM.AST.Operand.Operand>_R
                 ->_R Trans
                          (<CodeGen.CodegenState>_R
                           ->_R Sym (Data.Functor.Identity.N:Identity[0]
                                         <((), CodeGen.CodegenState)>_R))
                          (Trans
                               (Sym (Control.Monad.Trans.State.Lazy.N:StateT[0]
                                         <CodeGen.CodegenState>_N
                                         <Data.Functor.Identity.Identity>_R
                                         <()>_N))
                               (Sym (CodeGen.N:Codegen[0]) <()>_N))) -}
187de0a494fd9ebe41a0adf6305bf334
  assign1 ::
    GHC.Base.String
    -> LLVM.AST.Operand.Operand
    -> CodeGen.CodegenState
    -> ((), CodeGen.CodegenState)
  {- Arity: 3, HasNoCafRefs,
     Strictness: <L,U><L,U><L,1*U(U,U,U,U,U,U)>m,
     Unfolding: InlineRule (3, True, False)
                (\ (var :: GHC.Base.String)
                   (x :: LLVM.AST.Operand.Operand)
                   (eta :: CodeGen.CodegenState) ->
                 (GHC.Tuple.(),
                  case eta of wild { CodeGen.CodegenState ds ds1 ds2 ds3 ds4 ds5 ->
                  CodeGen.CodegenState
                    ds
                    ds1
                    (GHC.Types.:
                       @ (GHC.Base.String, LLVM.AST.Operand.Operand)
                       (var, x)
                       ds2)
                    ds3
                    ds4
                    ds5 })) -}
e7d0189858a2d31fce3c4c276290cb14
  blockCount :: CodeGen.CodegenState -> GHC.Types.Int
  RecSel Left CodeGen.CodegenState
  {- Arity: 1, HasNoCafRefs,
     Strictness: <S(LLLSLL),1*U(A,A,A,1*U(U),A,A)>m,
     Unfolding: InlineRule (1, True, False)
                (\ (ds :: CodeGen.CodegenState) ->
                 case ds of wild { CodeGen.CodegenState ds1 ds2 ds3 ds4 ds5 ds6 ->
                 ds4 }) -}
428672f9ad9904f7b98e2d72805864be
  blocks ::
    CodeGen.CodegenState
    -> Data.Map.Base.Map LLVM.AST.Name.Name CodeGen.BlockState
  RecSel Left CodeGen.CodegenState
  {- Arity: 1, HasNoCafRefs,
     Strictness: <S(LSLLLL),1*U(A,1*U,A,A,A,A)>,
     Unfolding: InlineRule (1, True, False)
                (\ (ds :: CodeGen.CodegenState) ->
                 case ds of wild { CodeGen.CodegenState ds1 ds2 ds3 ds4 ds5 ds6 ->
                 ds2 }) -}
98019c3839c233de1a1adff80563174c
  count :: CodeGen.CodegenState -> GHC.Types.Word
  RecSel Left CodeGen.CodegenState
  {- Arity: 1, HasNoCafRefs,
     Strictness: <S(LLLLSL),1*U(A,A,A,A,1*U(U),A)>m,
     Unfolding: InlineRule (1, True, False)
                (\ (ds :: CodeGen.CodegenState) ->
                 case ds of wild { CodeGen.CodegenState ds1 ds2 ds3 ds4 ds5 ds6 ->
                 ds5 }) -}
60afa196427492de0f1957dbbeac5e76
  createBlocks ::
    CodeGen.CodegenState -> [LLVM.AST.Global.BasicBlock]
  {- Arity: 1, Strictness: <S(LSLLLL),1*U(A,1*U,A,A,A,A)>,
     Inline: INLINE[0],
     Unfolding: InlineRule (1, True, False)
                (\ (w :: CodeGen.CodegenState) ->
                 case w of ww { CodeGen.CodegenState ww1 ww2 ww3 ww4 ww5 ww6 ->
                 CodeGen.$wcreateBlocks ww2 }) -}
da0543bda5ff027bea178dff1b534c78
  createBlocks1 ::
    (LLVM.AST.Name.Name, CodeGen.BlockState)
    -> (LLVM.AST.Name.Name, CodeGen.BlockState) -> GHC.Types.Ordering
  {- Arity: 2, HasNoCafRefs,
     Strictness: <S(LS(S(S)LL)),1*U(A,1*U(1*U(U),A,A))><S(LS(S(S)LL)),1*U(A,1*U(1*U(U),A,A))>,
     Unfolding: InlineRule (2, True, False)
                (\ (x :: (LLVM.AST.Name.Name, CodeGen.BlockState))
                   (y :: (LLVM.AST.Name.Name, CodeGen.BlockState)) ->
                 case x of wild { (,) ds1 y1 ->
                 case y1 of wild1 { CodeGen.BlockState ds ds2 ds3 ->
                 case ds of wild2 { GHC.Types.I# x# ->
                 case y of wild3 { (,) ds4 y2 ->
                 case y2 of wild4 { CodeGen.BlockState ds5 ds6 ds7 ->
                 case ds5 of wild5 { GHC.Types.I# y# ->
                 GHC.Classes.compareInt# x# y# } } } } } }) -}
101e5e4b9ae3404d6ecdf94274770202
  current :: CodeGen.Codegen CodeGen.BlockState
  {- Arity: 1, Strictness: <S(SSLLLL),U(U,U,U,U,U,U)>m,
     Unfolding: InlineRule (0, True, True)
                CodeGen.current1
                  `cast`
                (Trans
                     (Sym (Control.Monad.Trans.State.Lazy.N:StateT[0]
                               <CodeGen.CodegenState>_N
                               <Data.Functor.Identity.Identity>_R
                               <CodeGen.BlockState>_N))
                     (Sym (CodeGen.N:Codegen[0]) <CodeGen.BlockState>_N)) -}
678e0ffc5bbfa82b06f2b1278fe0d11c
  current1 ::
    CodeGen.CodegenState
    -> Data.Functor.Identity.Identity
         (CodeGen.BlockState, CodeGen.CodegenState)
  {- Arity: 1, Strictness: <S(SSLLLL),U(U,U,U,U,U,U)>m,
     Inline: INLINE[0],
     Unfolding: InlineRule (1, True, False)
                (\ (w :: CodeGen.CodegenState) ->
                 case w of ww { CodeGen.CodegenState ww1 ww2 ww3 ww4 ww5 ww6 ->
                 case CodeGen.$slookup3 @ CodeGen.BlockState ww1 ww2 of wild {
                   GHC.Base.Nothing
                   -> case CodeGen.alloca4 ww1
                      ret_ty (Data.Functor.Identity.Identity
                                (CodeGen.BlockState, CodeGen.CodegenState))
                      of {}
                   GHC.Base.Just x
                   -> (x, CodeGen.CodegenState ww1 ww2 ww3 ww4 ww5 ww6)
                        `cast`
                      (Sym (Data.Functor.Identity.N:Identity[0]
                                <(CodeGen.BlockState, CodeGen.CodegenState)>_R)) } }) -}
ee44492fee3425bd654b3e1af554851c
  currentBlock :: CodeGen.CodegenState -> LLVM.AST.Name.Name
  RecSel Left CodeGen.CodegenState
  {- Arity: 1, HasNoCafRefs,
     Strictness: <S(SLLLLL),1*U(1*U,A,A,A,A,A)>,
     Unfolding: InlineRule (1, True, False)
                (\ (ds :: CodeGen.CodegenState) ->
                 case ds of wild { CodeGen.CodegenState ds1 ds2 ds3 ds4 ds5 ds6 ->
                 ds1 }) -}
4ee7b0bf384edf4a10f5792e637f59a3
  define ::
    LLVM.AST.Type.Type
    -> GHC.Base.String
    -> [(LLVM.AST.Type.Type, LLVM.AST.Name.Name)]
    -> [LLVM.AST.Global.BasicBlock]
    -> CodeGen.LLVM ()
  {- Arity: 4, HasNoCafRefs, Strictness: <L,U><L,U><L,1*U><L,U>,
     Unfolding: (\ (retty :: LLVM.AST.Type.Type)
                   (label :: GHC.Base.String)
                   (argtys :: [(LLVM.AST.Type.Type, LLVM.AST.Name.Name)])
                   (body :: [LLVM.AST.Global.BasicBlock]) ->
                 let {
                   def :: LLVM.AST.Name.Name = LLVM.AST.Name.Name label
                 } in
                 let {
                   def1 :: [LLVM.AST.Global.Parameter] = CodeGen.define_go argtys
                 } in
                 let {
                   def2 :: ([LLVM.AST.Global.Parameter], GHC.Types.Bool)
                     {- Strictness: m -}
                   = (def1, GHC.Types.False)
                 } in
                 let {
                   def3 :: LLVM.AST.Global.Global
                   = LLVM.AST.Global.Function
                       LLVM.AST.Linkage.External
                       LLVM.AST.Visibility.Default
                       (GHC.Base.Nothing @ LLVM.AST.DLL.StorageClass)
                       LLVM.AST.CallingConvention.C
                       (GHC.Types.[] @ LLVM.AST.ParameterAttribute.ParameterAttribute)
                       retty
                       def
                       def2
                       (GHC.Types.[]
                          @ (Data.Either.Either
                               LLVM.AST.FunctionAttribute.GroupID
                               LLVM.AST.FunctionAttribute.FunctionAttribute))
                       (GHC.Base.Nothing @ GHC.Base.String)
                       (GHC.Base.Nothing @ GHC.Base.String)
                       LLVM.AST.Global.functionDefaults1
                       (GHC.Base.Nothing @ GHC.Base.String)
                       (GHC.Base.Nothing @ LLVM.AST.Constant.Constant)
                       body
                       (GHC.Base.Nothing @ LLVM.AST.Constant.Constant)
                 } in
                 let {
                   def4 :: LLVM.AST.Definition = LLVM.AST.GlobalDefinition def3
                 } in
                 (\ (eta :: LLVM.AST.Module) ->
                  (GHC.Tuple.(),
                   case eta of wild { LLVM.AST.Module ds ds1 ds2 ds3 ds4 ->
                   LLVM.AST.Module
                     ds
                     ds1
                     ds2
                     ds3
                     (GHC.Types.: @ LLVM.AST.Definition def4 ds4) }))
                   `cast`
                 (Trans
                      (<LLVM.AST.Module>_R
                       ->_R Sym (Data.Functor.Identity.N:Identity[0]
                                     <((), LLVM.AST.Module)>_R))
                      (Trans
                           (Sym (Control.Monad.Trans.State.Lazy.N:StateT[0]
                                     <LLVM.AST.Module>_N <Data.Functor.Identity.Identity>_R <()>_N))
                           (Sym (CodeGen.N:LLVM[0]) <()>_N)))) -}
06d0089906fca7174ed7894d5bc5af53
  define_go ::
    [(LLVM.AST.Type.Type, LLVM.AST.Name.Name)]
    -> [LLVM.AST.Global.Parameter]
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U> -}
70223de8e9874eaf48e17cc39f984be4
  emptyBlock :: GHC.Types.Int -> CodeGen.BlockState
  {- Arity: 1, HasNoCafRefs, Strictness: <L,U>m,
     Unfolding: InlineRule (1, True, False)
                (\ (i :: GHC.Types.Int) ->
                 CodeGen.BlockState
                   i
                   (GHC.Types.[]
                      @ (LLVM.AST.Instruction.Named LLVM.AST.Instruction.Instruction))
                   (GHC.Base.Nothing
                      @ (LLVM.AST.Instruction.Named LLVM.AST.Instruction.Terminator))) -}
bcf7586a52904e8074317f68333e13ff
  emptyCodegen :: CodeGen.CodegenState
  {- Strictness: m,
     Unfolding: (CodeGen.CodegenState
                   CodeGen.emptyCodegen3
                   (Data.Map.Base.Tip @ LLVM.AST.Name.Name @ CodeGen.BlockState)
                   (GHC.Types.[] @ (GHC.Base.String, LLVM.AST.Operand.Operand))
                   CodeGen.emptyCodegen2
                   CodeGen.emptyCodegen1
                   (Data.Map.Base.Tip @ GHC.Base.String @ GHC.Types.Int)) -}
40d7617b710194ab91493e9014771833
  emptyCodegen1 :: GHC.Types.Word
  {- HasNoCafRefs, Strictness: m, Unfolding: (GHC.Types.W# 0##) -}
42917157d57d4d14bee8ae3d5fcac131
  emptyCodegen2 :: GHC.Types.Int
  {- HasNoCafRefs, Strictness: m, Unfolding: (GHC.Types.I# 1#) -}
0e7eb85e087c9140fe6f02079992a5fe
  emptyCodegen3 :: LLVM.AST.Name.Name
  {- Strictness: m1,
     Unfolding: (LLVM.AST.Name.Name CodeGen.entryBlockName) -}
a66d2d9b30826c36c56862673b5df0fa
  entryBlockName :: GHC.Base.String
  {- Unfolding: (GHC.CString.unpackCString# "entry"#) -}
a195cdfda7d2849a82c58e4e202a3414
  execCodegen :: CodeGen.Codegen a -> CodeGen.CodegenState
  {- Arity: 1, Strictness: <C(S(LS)),1*C1(U(A,1*U(U,U,U,U,U,U)))>,
     Unfolding: InlineRule (1, True, False)
                (\ @ a (m :: CodeGen.Codegen a) ->
                 case (m `cast`
                       (Trans
                            (CodeGen.N:Codegen[0] <a>_N)
                            (Control.Monad.Trans.State.Lazy.N:StateT[0]
                                 <CodeGen.CodegenState>_N <Data.Functor.Identity.Identity>_R <a>_N))
                         CodeGen.emptyCodegen)
                        `cast`
                      (Data.Functor.Identity.N:Identity[0]
                           <(a, CodeGen.CodegenState)>_R) of wild { (,) ds1 y ->
                 y }) -}
1fa19fecd30ce805b267d2c60ead0d87
  fresh :: CodeGen.Codegen GHC.Types.Word
  {- Arity: 1, HasNoCafRefs, Strictness: <L,U(U,U,U,U,1*U(U),U)>m,
     Unfolding: InlineRule (0, True, True)
                CodeGen.fresh1
                  `cast`
                (Trans
                     (Sym (Control.Monad.Trans.State.Lazy.N:StateT[0]
                               <CodeGen.CodegenState>_N
                               <Data.Functor.Identity.Identity>_R
                               <GHC.Types.Word>_N))
                     (Sym (CodeGen.N:Codegen[0]) <GHC.Types.Word>_N)) -}
6c115105573dc1b36a7817f3cbbf8ea3
  fresh1 ::
    CodeGen.CodegenState
    -> Data.Functor.Identity.Identity
         (GHC.Types.Word, CodeGen.CodegenState)
  {- Arity: 1, HasNoCafRefs, Strictness: <L,U(U,U,U,U,1*U(U),U)>m,
     Inline: INLINE[0],
     Unfolding: InlineRule (1, True, False)
                (\ (w :: CodeGen.CodegenState) ->
                 let {
                   i :: GHC.Types.Word
                   = case w of wild { CodeGen.CodegenState ds ds1 ds2 ds3 ds4 ds5 ->
                     ds4 }
                 } in
                 (case i of wild { GHC.Types.W# x# ->
                  GHC.Types.W# (GHC.Prim.plusWord# x# 1##) },
                  case w of wild { CodeGen.CodegenState ds ds1 ds2 ds3 ds4 ds5 ->
                  CodeGen.CodegenState
                    ds
                    ds1
                    ds2
                    ds3
                    (case i of wild1 { GHC.Types.W# y# ->
                     GHC.Types.W# (GHC.Prim.plusWord# 1## y#) })
                    ds5 })
                   `cast`
                 (Sym (Data.Functor.Identity.N:Identity[0]
                           <(GHC.Types.Word, CodeGen.CodegenState)>_R))) -}
32ee015c3be344b24229eef7ae0b98b2
  getArgList ::
    AST.ArgList -> [(LLVM.AST.Type.Type, LLVM.AST.Name.Name)]
  {- Arity: 1,
     Unfolding: (GHC.Base.map
                   @ (AST.Type, AST.Name)
                   @ (LLVM.AST.Type.Type, LLVM.AST.Name.Name)
                   CodeGen.getArgList1) -}
a3b706e5eaee7017f2ac5c5969d894f0
  getArgList1 ::
    (AST.Type, AST.Name) -> (LLVM.AST.Type.Type, LLVM.AST.Name.Name)
  {- Arity: 1, Strictness: <S,1*U(1*U,U)>m,
     Unfolding: InlineRule (1, True, False)
                (\ (ds :: (AST.Type, AST.Name)) ->
                 case ds of wild { (,) t n ->
                 (case t of wild1 {
                    AST.IntC -> CodeGen.getArgList3
                    AST.StringC -> CodeGen.getArgList2 },
                  LLVM.AST.Name.Name n) }) -}
f41ed15f432770f248539ea35d28e9ee
  getArgList2 :: LLVM.AST.Type.Type
  {- Strictness: x -}
84293b1a5e293e0b8c43e245f98f7daa
  getArgList3 :: LLVM.AST.Type.Type
  {- Strictness: m2, Unfolding: (CodeGen.intL) -}
db7fde4237170a3cf915f6b31b8d126d
  getDef :: AST.Func -> LLVM.AST.Definition
  {- Arity: 1, Strictness: <S,1*U(U,1*U,1*U,A)>m1, Inline: INLINE[0],
     Unfolding: InlineRule (1, True, False)
                (\ (w :: AST.Func) ->
                 case w of ww { AST.Func ww1 ww2 ww3 ww4 ->
                 LLVM.AST.GlobalDefinition
                   (LLVM.AST.Global.Function
                      LLVM.AST.Linkage.External
                      LLVM.AST.Visibility.Default
                      (GHC.Base.Nothing @ LLVM.AST.DLL.StorageClass)
                      LLVM.AST.CallingConvention.C
                      (GHC.Types.[] @ LLVM.AST.ParameterAttribute.ParameterAttribute)
                      (case ww3 of wild {
                         AST.IntC -> CodeGen.intL AST.StringC -> CodeGen.getArgList2 })
                      (LLVM.AST.Name.Name ww1)
                      (CodeGen.getDef_go ww2, GHC.Types.False)
                      (GHC.Types.[]
                         @ (Data.Either.Either
                              LLVM.AST.FunctionAttribute.GroupID
                              LLVM.AST.FunctionAttribute.FunctionAttribute))
                      (GHC.Base.Nothing @ GHC.Base.String)
                      (GHC.Base.Nothing @ GHC.Base.String)
                      LLVM.AST.Global.functionDefaults1
                      (GHC.Base.Nothing @ GHC.Base.String)
                      (GHC.Base.Nothing @ LLVM.AST.Constant.Constant)
                      (GHC.Types.[] @ LLVM.AST.Global.BasicBlock)
                      (GHC.Base.Nothing @ LLVM.AST.Constant.Constant)) }) -}
9915f5da3afcc2f81db9232d085c83eb
  getDef_go :: [(AST.Type, AST.Name)] -> [LLVM.AST.Global.Parameter]
  {- Arity: 1, Strictness: <S,1*U> -}
79efe6fb76526dbd1eb795ad96924c5c
  getExtern :: AST.Declaration -> LLVM.AST.Definition
  {- Arity: 1, Strictness: <S,1*U>m1, Inline: INLINE[0],
     Unfolding: InlineRule (1, True, False)
                (\ (w :: AST.Declaration) ->
                 case w of wild {
                   AST.ExternDecl fname fargs fret
                   -> LLVM.AST.GlobalDefinition
                        (LLVM.AST.Global.Function
                           LLVM.AST.Linkage.External
                           LLVM.AST.Visibility.Default
                           (GHC.Base.Nothing @ LLVM.AST.DLL.StorageClass)
                           LLVM.AST.CallingConvention.C
                           (GHC.Types.[] @ LLVM.AST.ParameterAttribute.ParameterAttribute)
                           (case fret of wild1 {
                              AST.IntC -> CodeGen.intL AST.StringC -> CodeGen.getArgList2 })
                           (LLVM.AST.Name.Name fname)
                           (CodeGen.getDef_go fargs, GHC.Types.False)
                           (GHC.Types.[]
                              @ (Data.Either.Either
                                   LLVM.AST.FunctionAttribute.GroupID
                                   LLVM.AST.FunctionAttribute.FunctionAttribute))
                           (GHC.Base.Nothing @ GHC.Base.String)
                           (GHC.Base.Nothing @ GHC.Base.String)
                           LLVM.AST.Global.functionDefaults1
                           (GHC.Base.Nothing @ GHC.Base.String)
                           (GHC.Base.Nothing @ LLVM.AST.Constant.Constant)
                           (GHC.Types.[] @ LLVM.AST.Global.BasicBlock)
                           (GHC.Base.Nothing @ LLVM.AST.Constant.Constant))
                   AST.VarDecl ipv ipv1 -> CodeGen.getExtern1 }) -}
87fbd23dc8bc8cb3e53f00dea4045214
  getExtern1 :: LLVM.AST.Definition
  {- Strictness: x -}
4f97f17854f6b54244622f81396b90a8
  getName :: AST.Name -> LLVM.AST.Name.Name
  {- Arity: 1, HasNoCafRefs, Strictness: <L,U>m1,
     Unfolding: InlineRule (0, True, True) LLVM.AST.Name.Name -}
6119272511ab106fe389fe8aa76856ab
  getType :: AST.Type -> LLVM.AST.Type.Type
  {- Arity: 1, Strictness: <S,1*U>m2,
     Unfolding: InlineRule (1, True, False)
                (\ (ds :: AST.Type) ->
                 case ds of wild {
                   AST.IntC -> CodeGen.getArgList3
                   AST.StringC -> CodeGen.getArgList2 }) -}
82533dc49ec446042fde2d7b8ff0be63
  getvar ::
    GHC.Base.String -> CodeGen.Codegen LLVM.AST.Operand.Operand
  {- Arity: 2, Strictness: <L,U><S(LLSLLL),1*U(U,U,U,U,U,U)>m,
     Unfolding: InlineRule (0, True, True)
                CodeGen.getvar1
                  `cast`
                (<GHC.Base.String>_R
                 ->_R Trans
                          (Sym (Control.Monad.Trans.State.Lazy.N:StateT[0]
                                    <CodeGen.CodegenState>_N
                                    <Data.Functor.Identity.Identity>_R
                                    <LLVM.AST.Operand.Operand>_N))
                          (Sym (CodeGen.N:Codegen[0]) <LLVM.AST.Operand.Operand>_N)) -}
179568db806f539f6ab8501b4d68ba28
  getvar1 ::
    GHC.Base.String
    -> CodeGen.CodegenState
    -> Data.Functor.Identity.Identity
         (LLVM.AST.Operand.Operand, CodeGen.CodegenState)
  {- Arity: 2, Strictness: <L,U><S(LLSLLL),1*U(U,U,U,U,U,U)>m,
     Inline: INLINE[0],
     Unfolding: InlineRule (2, True, False)
                (\ (w :: GHC.Base.String) (w1 :: CodeGen.CodegenState) ->
                 case w1 of ww { CodeGen.CodegenState ww1 ww2 ww3 ww4 ww5 ww6 ->
                 case GHC.List.lookup
                        @ GHC.Base.String
                        @ LLVM.AST.Operand.Operand
                        GHC.Classes.$fEq[]_$s$fEq[]1
                        w
                        ww3 of wild {
                   GHC.Base.Nothing
                   -> case CodeGen.getvar2 w
                      ret_ty (Data.Functor.Identity.Identity
                                (LLVM.AST.Operand.Operand, CodeGen.CodegenState))
                      of {}
                   GHC.Base.Just x
                   -> (x, CodeGen.CodegenState ww1 ww2 ww3 ww4 ww5 ww6)
                        `cast`
                      (Sym (Data.Functor.Identity.N:Identity[0]
                                <(LLVM.AST.Operand.Operand, CodeGen.CodegenState)>_R)) } }) -}
04369394190cc4a56a1fe38e12fc7e4b
  getvar2 ::
    GHC.Base.String -> CodeGen.Codegen LLVM.AST.Operand.Operand
  {- Arity: 1, Strictness: <L,U>x -}
3e472f7faa223eff96eb0b334f286602
  idx :: CodeGen.BlockState -> GHC.Types.Int
  RecSel Left CodeGen.BlockState
  {- Arity: 1, HasNoCafRefs, Strictness: <S(SLL),1*U(1*U(U),A,A)>m,
     Unfolding: InlineRule (1, True, False)
                (\ (ds :: CodeGen.BlockState) ->
                 case ds of wild { CodeGen.BlockState ds1 ds2 ds3 -> ds1 }) -}
a616ca62ae74077d377dcd93bd7510dc
  instr ::
    LLVM.AST.Instruction.Instruction
    -> CodeGen.Codegen LLVM.AST.Operand.Operand
  {- Arity: 2, Strictness: <L,U><L,U(U,U,U,U,1*U(U),U)>m,
     Unfolding: InlineRule (0, True, True)
                CodeGen.alloca3
                  `cast`
                (<LLVM.AST.Instruction.Instruction>_R
                 ->_R Trans
                          (Sym (Control.Monad.Trans.State.Lazy.N:StateT[0]
                                    <CodeGen.CodegenState>_N
                                    <Data.Functor.Identity.Identity>_R
                                    <LLVM.AST.Operand.Operand>_N))
                          (Sym (CodeGen.N:Codegen[0]) <LLVM.AST.Operand.Operand>_N)) -}
3cc7ae9ae96297712bd68fbe36bdd00e
  intL :: LLVM.AST.Type.Type
  {- HasNoCafRefs, Strictness: m2,
     Unfolding: (LLVM.AST.Type.IntegerType CodeGen.intL1) -}
9357baf9ec45e30971b3ee33e8a3c55e
  intL1 :: GHC.Word.Word32
  {- HasNoCafRefs, Strictness: m, Unfolding: (GHC.Word.W32# 32##) -}
bb5a0c57a99b154152f55da79c9151c0
  load ::
    LLVM.AST.Operand.Operand
    -> CodeGen.Codegen LLVM.AST.Operand.Operand
  {- Arity: 2, Strictness: <L,U><L,U(U,U,U,U,U(U),U)>m,
     Unfolding: InlineRule (0, True, True)
                CodeGen.load1
                  `cast`
                (<LLVM.AST.Operand.Operand>_R
                 ->_R Trans
                          (Sym (Control.Monad.Trans.State.Lazy.N:StateT[0]
                                    <CodeGen.CodegenState>_N
                                    <Data.Functor.Identity.Identity>_R
                                    <LLVM.AST.Operand.Operand>_N))
                          (Sym (CodeGen.N:Codegen[0]) <LLVM.AST.Operand.Operand>_N)) -}
907a064a8f7ed70be7dad5a2f5561770
  load1 ::
    LLVM.AST.Operand.Operand
    -> CodeGen.CodegenState
    -> Data.Functor.Identity.Identity
         (LLVM.AST.Operand.Operand, CodeGen.CodegenState)
  {- Arity: 2, Strictness: <L,U><L,U(U,U,U,U,U(U),U)>m,
     Unfolding: InlineRule (2, True, False)
                (\ (ptr :: LLVM.AST.Operand.Operand)
                   (eta :: CodeGen.CodegenState) ->
                 CodeGen.alloca3
                   (LLVM.AST.Instruction.Load
                      GHC.Types.False
                      ptr
                      (GHC.Base.Nothing @ LLVM.AST.Instruction.Atomicity)
                      CodeGen.alloca2
                      (GHC.Types.[] @ (GHC.Base.String, LLVM.AST.Operand.MetadataNode)))
                   eta) -}
66036a9923a3b76ccf8bd1f24ccbb5ed
  local :: LLVM.AST.Name.Name -> LLVM.AST.Operand.Operand
  {- Arity: 1, HasNoCafRefs,
     Unfolding: (LLVM.AST.Operand.LocalReference
                   LLVM.AST.Type.double) -}
8e3dfce715e779ea22e48c6ea97bcbbf
  makeBlock ::
    (LLVM.AST.Name.Name, CodeGen.BlockState)
    -> LLVM.AST.Global.BasicBlock
  {- Arity: 1, Strictness: <S(LS),1*U(U,1*U(A,1*U,1*U))>m,
     Inline: INLINE[0],
     Unfolding: InlineRule (1, True, False)
                (\ (w :: (LLVM.AST.Name.Name, CodeGen.BlockState)) ->
                 case w of ww { (,) ww1 ww2 ->
                 case ww2 of ww3 { CodeGen.BlockState ww4 ww5 ww6 ->
                 LLVM.AST.Global.BasicBlock
                   ww1
                   (GHC.List.reverse
                      @ (LLVM.AST.Instruction.Named LLVM.AST.Instruction.Instruction)
                      ww5)
                   (case ww6 of wild {
                      GHC.Base.Nothing -> CodeGen.makeBlock1 ww1
                      GHC.Base.Just x -> x }) } }) -}
f05058bdba189f6b62b114dd76c87b12
  makeBlock1 ::
    LLVM.AST.Name.Name
    -> LLVM.AST.Instruction.Named LLVM.AST.Instruction.Terminator
  {- Arity: 1, Strictness: <L,U>x -}
25b2a782d23ad261656972e0fae246f0
  modifyBlock :: CodeGen.BlockState -> CodeGen.Codegen ()
  {- Arity: 2, Strictness: <L,U><L,1*U(U,1*U,U,U,U,U)>m,
     Unfolding: InlineRule (0, True, True)
                CodeGen.modifyBlock1
                  `cast`
                (<CodeGen.BlockState>_R
                 ->_R Trans
                          (<CodeGen.CodegenState>_R
                           ->_R Sym (Data.Functor.Identity.N:Identity[0]
                                         <((), CodeGen.CodegenState)>_R))
                          (Trans
                               (Sym (Control.Monad.Trans.State.Lazy.N:StateT[0]
                                         <CodeGen.CodegenState>_N
                                         <Data.Functor.Identity.Identity>_R
                                         <()>_N))
                               (Sym (CodeGen.N:Codegen[0]) <()>_N))) -}
2b4e2d35abf7b78af9aadeaed9bbd7ba
  modifyBlock1 ::
    CodeGen.BlockState
    -> CodeGen.CodegenState -> ((), CodeGen.CodegenState)
  {- Arity: 2, Strictness: <L,U><L,1*U(U,1*U,U,U,U,U)>m,
     Unfolding: InlineRule (2, True, False)
                (\ (new :: CodeGen.BlockState) (eta :: CodeGen.CodegenState) ->
                 (GHC.Tuple.(),
                  case eta of wild { CodeGen.CodegenState ds ds1 ds2 ds3 ds4 ds5 ->
                  CodeGen.CodegenState
                    ds
                    (CodeGen.$sinsert_$sgo1 @ CodeGen.BlockState ds new ds1)
                    ds2
                    ds3
                    ds4
                    ds5 })) -}
d2b9c338d28c5fb7424732dbcece8c4f
  names :: CodeGen.CodegenState -> CodeGen.Names
  RecSel Left CodeGen.CodegenState
  {- Arity: 1, HasNoCafRefs,
     Strictness: <S(LLLLLS),1*U(A,A,A,A,A,1*U)>,
     Unfolding: InlineRule (1, True, False)
                (\ (ds :: CodeGen.CodegenState) ->
                 case ds of wild { CodeGen.CodegenState ds1 ds2 ds3 ds4 ds5 ds6 ->
                 ds6 }) -}
79e0d932aecf137b091b7aa0e12513dc
  ret ::
    LLVM.AST.Operand.Operand
    -> CodeGen.Codegen
         (LLVM.AST.Instruction.Named LLVM.AST.Instruction.Terminator)
  {- Arity: 2, Strictness: <L,U><L,U(U,U,U,U,U,U)>m,
     Unfolding: InlineRule (0, True, True)
                CodeGen.ret1
                  `cast`
                (<LLVM.AST.Operand.Operand>_R
                 ->_R Trans
                          (<CodeGen.CodegenState>_R
                           ->_R Sym (Data.Functor.Identity.N:Identity[0]
                                         <(LLVM.AST.Instruction.Named
                                             LLVM.AST.Instruction.Terminator,
                                           CodeGen.CodegenState)>_R))
                          (Trans
                               (Sym (Control.Monad.Trans.State.Lazy.N:StateT[0]
                                         <CodeGen.CodegenState>_N
                                         <Data.Functor.Identity.Identity>_R
                                         <LLVM.AST.Instruction.Named
                                            LLVM.AST.Instruction.Terminator>_N))
                               (Sym (CodeGen.N:Codegen[0]) <LLVM.AST.Instruction.Named
                                                              LLVM.AST.Instruction.Terminator>_N))) -}
2cfa6adef15cb7e9630133e2671c0735
  ret1 ::
    LLVM.AST.Operand.Operand
    -> CodeGen.CodegenState
    -> (LLVM.AST.Instruction.Named LLVM.AST.Instruction.Terminator,
        CodeGen.CodegenState)
  {- Arity: 2, Strictness: <L,U><L,U(U,U,U,U,U,U)>m,
     Unfolding: InlineRule (2, True, False)
                (\ (val :: LLVM.AST.Operand.Operand)
                   (eta :: CodeGen.CodegenState) ->
                 CodeGen.ret2
                   (LLVM.AST.Instruction.Do
                      @ LLVM.AST.Instruction.Terminator
                      (LLVM.AST.Instruction.Ret
                         (GHC.Base.Just @ LLVM.AST.Operand.Operand val)
                         (GHC.Types.[] @ (GHC.Base.String, LLVM.AST.Operand.MetadataNode))))
                   eta) -}
92658b3d6335ad759e0a5942d1332d10
  ret2 ::
    LLVM.AST.Instruction.Named LLVM.AST.Instruction.Terminator
    -> CodeGen.CodegenState
    -> (LLVM.AST.Instruction.Named LLVM.AST.Instruction.Terminator,
        CodeGen.CodegenState)
  {- Arity: 2, Strictness: <L,U><L,U(U,U,U,U,U,U)>m,
     Inline: INLINE[0],
     Unfolding: InlineRule (2, True, False)
                (\ (w :: LLVM.AST.Instruction.Named
                           LLVM.AST.Instruction.Terminator)
                   (w1 :: CodeGen.CodegenState) ->
                 case CodeGen.$wterminator w w1 of ww { (#,#) ww1 ww2 ->
                 (ww1, ww2) }) -}
8d082ff4d7a2c6c219be62bc6b7eabca
  runCodegen ::
    CodeGen.Codegen a
    -> Control.Monad.Trans.State.Lazy.State CodeGen.CodegenState a
  RecSel Left CodeGen.Codegen
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U>,
     Unfolding: InlineRule (0, True, True)
                CodeGen.runCodegen1
                  `cast`
                (forall (a :: <*>_N).
                 <CodeGen.Codegen a>_R ->_R CodeGen.N:Codegen[0] <a>_N) -}
1f8ba05f9a1c3e6b9993f8b01c89c82a
  runCodegen1 :: CodeGen.Codegen a -> CodeGen.Codegen a
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U>,
     Unfolding: InlineRule (1, True, True)
                (\ @ a (ds :: CodeGen.Codegen a) -> ds) -}
833fce218ae49848d26d7f01bc631a4b
  runLLVM :: LLVM.AST.Module -> CodeGen.LLVM a -> LLVM.AST.Module
  {- Arity: 2, HasNoCafRefs,
     Strictness: <L,U><C(S(LS)),1*C1(U(A,1*U))>,
     Unfolding: InlineRule (2, True, True)
                (\ @ a (mod :: LLVM.AST.Module) (ds :: CodeGen.LLVM a) ->
                 Control.Monad.Trans.State.Lazy.execState
                   @ LLVM.AST.Module
                   @ a
                   ds `cast` (CodeGen.N:LLVM[0] <a>_N)
                   mod) -}
8d50ed543f033220c1e5e58a3f6c9f14
  setBlock ::
    LLVM.AST.Name.Name -> CodeGen.Codegen LLVM.AST.Name.Name
  {- Arity: 2, HasNoCafRefs, Strictness: <L,U><L,1*U(A,U,U,U,U,U)>m,
     Unfolding: InlineRule (0, True, True)
                CodeGen.setBlock1
                  `cast`
                (<LLVM.AST.Name.Name>_R
                 ->_R Trans
                          (<CodeGen.CodegenState>_R
                           ->_R Sym (Data.Functor.Identity.N:Identity[0]
                                         <(LLVM.AST.Name.Name, CodeGen.CodegenState)>_R))
                          (Trans
                               (Sym (Control.Monad.Trans.State.Lazy.N:StateT[0]
                                         <CodeGen.CodegenState>_N
                                         <Data.Functor.Identity.Identity>_R
                                         <LLVM.AST.Name.Name>_N))
                               (Sym (CodeGen.N:Codegen[0]) <LLVM.AST.Name.Name>_N))) -}
bed3736e8c906ecce32aa5d308881336
  setBlock1 ::
    LLVM.AST.Name.Name
    -> CodeGen.CodegenState
    -> (LLVM.AST.Name.Name, CodeGen.CodegenState)
  {- Arity: 2, HasNoCafRefs, Strictness: <L,U><L,1*U(A,U,U,U,U,U)>m,
     Unfolding: InlineRule (2, True, False)
                (\ (bname :: LLVM.AST.Name.Name) (eta :: CodeGen.CodegenState) ->
                 (bname,
                  case eta of wild { CodeGen.CodegenState ds ds1 ds2 ds3 ds4 ds5 ->
                  CodeGen.CodegenState bname ds1 ds2 ds3 ds4 ds5 })) -}
e97fcad093f0378f9e8987a59a8246f1
  sortBlocks ::
    [(LLVM.AST.Name.Name, CodeGen.BlockState)]
    -> [(LLVM.AST.Name.Name, CodeGen.BlockState)]
  {- Arity: 1, HasNoCafRefs,
     Unfolding: (Data.OldList.sortBy
                   @ (LLVM.AST.Name.Name, CodeGen.BlockState)
                   CodeGen.createBlocks1) -}
4c3355fab199eaaad5add8d2ae8a9c69
  stack ::
    CodeGen.BlockState
    -> [LLVM.AST.Instruction.Named LLVM.AST.Instruction.Instruction]
  RecSel Left CodeGen.BlockState
  {- Arity: 1, HasNoCafRefs, Strictness: <S(LSL),1*U(A,1*U,A)>,
     Unfolding: InlineRule (1, True, False)
                (\ (ds :: CodeGen.BlockState) ->
                 case ds of wild { CodeGen.BlockState ds1 ds2 ds3 -> ds2 }) -}
684a75d57455134eb85abd81f14d1638
  store ::
    LLVM.AST.Operand.Operand
    -> LLVM.AST.Operand.Operand
    -> CodeGen.Codegen LLVM.AST.Operand.Operand
  {- Arity: 3, Strictness: <L,U><L,U><L,U(U,U,U,U,U(U),U)>m,
     Unfolding: InlineRule (0, True, True)
                CodeGen.store1
                  `cast`
                (<LLVM.AST.Operand.Operand>_R
                 ->_R <LLVM.AST.Operand.Operand>_R
                 ->_R Trans
                          (Sym (Control.Monad.Trans.State.Lazy.N:StateT[0]
                                    <CodeGen.CodegenState>_N
                                    <Data.Functor.Identity.Identity>_R
                                    <LLVM.AST.Operand.Operand>_N))
                          (Sym (CodeGen.N:Codegen[0]) <LLVM.AST.Operand.Operand>_N)) -}
560f92e4d6e59a1feeae36bfd5daa17b
  store1 ::
    LLVM.AST.Operand.Operand
    -> LLVM.AST.Operand.Operand
    -> CodeGen.CodegenState
    -> Data.Functor.Identity.Identity
         (LLVM.AST.Operand.Operand, CodeGen.CodegenState)
  {- Arity: 3, Strictness: <L,U><L,U><L,U(U,U,U,U,U(U),U)>m,
     Unfolding: InlineRule (3, True, False)
                (\ (ptr :: LLVM.AST.Operand.Operand)
                   (val :: LLVM.AST.Operand.Operand)
                   (eta :: CodeGen.CodegenState) ->
                 CodeGen.alloca3
                   (LLVM.AST.Instruction.Store
                      GHC.Types.False
                      ptr
                      val
                      (GHC.Base.Nothing @ LLVM.AST.Instruction.Atomicity)
                      CodeGen.alloca2
                      (GHC.Types.[] @ (GHC.Base.String, LLVM.AST.Operand.MetadataNode)))
                   eta) -}
fd8802c88014e1c0a0f40c28b57a8c2e
  symtab :: CodeGen.CodegenState -> CodeGen.SymbolTable
  RecSel Left CodeGen.CodegenState
  {- Arity: 1, HasNoCafRefs,
     Strictness: <S(LLSLLL),1*U(A,A,1*U,A,A,A)>,
     Unfolding: InlineRule (1, True, False)
                (\ (ds :: CodeGen.CodegenState) ->
                 case ds of wild { CodeGen.CodegenState ds1 ds2 ds3 ds4 ds5 ds6 ->
                 ds3 }) -}
912d992e4b31dd6a79ade5e5c5d1a8ff
  term ::
    CodeGen.BlockState
    -> GHC.Base.Maybe
         (LLVM.AST.Instruction.Named LLVM.AST.Instruction.Terminator)
  RecSel Left CodeGen.BlockState
  {- Arity: 1, HasNoCafRefs, Strictness: <S(LLS),1*U(A,A,1*U)>,
     Unfolding: InlineRule (1, True, False)
                (\ (ds :: CodeGen.BlockState) ->
                 case ds of wild { CodeGen.BlockState ds1 ds2 ds3 -> ds3 }) -}
88dbd2f97f8cba5f23c7861d3986b7b6
  terminator ::
    LLVM.AST.Instruction.Named LLVM.AST.Instruction.Terminator
    -> CodeGen.Codegen
         (LLVM.AST.Instruction.Named LLVM.AST.Instruction.Terminator)
  {- Arity: 2, Strictness: <L,U><L,U(U,U,U,U,U,U)>m,
     Unfolding: InlineRule (0, True, True)
                CodeGen.ret2
                  `cast`
                (<LLVM.AST.Instruction.Named LLVM.AST.Instruction.Terminator>_R
                 ->_R Trans
                          (<CodeGen.CodegenState>_R
                           ->_R Sym (Data.Functor.Identity.N:Identity[0]
                                         <(LLVM.AST.Instruction.Named
                                             LLVM.AST.Instruction.Terminator,
                                           CodeGen.CodegenState)>_R))
                          (Trans
                               (Sym (Control.Monad.Trans.State.Lazy.N:StateT[0]
                                         <CodeGen.CodegenState>_N
                                         <Data.Functor.Identity.Identity>_R
                                         <LLVM.AST.Instruction.Named
                                            LLVM.AST.Instruction.Terminator>_N))
                               (Sym (CodeGen.N:Codegen[0]) <LLVM.AST.Instruction.Named
                                                              LLVM.AST.Instruction.Terminator>_N))) -}
e428722fa26c1ad952d3b6fddd1269a8
  unikName ::
    GHC.Base.String
    -> CodeGen.Names -> (GHC.Base.String, CodeGen.Names)
  {- Arity: 2, Strictness: <S,U><S,U>m, Inline: INLINE[0],
     Unfolding: InlineRule (2, True, False)
                (\ (w :: GHC.Base.String) (w1 :: CodeGen.Names) ->
                 case CodeGen.$wunikName w w1 of ww { (#,#) ww1 ww2 ->
                 (ww1, ww2) }) -}
instance GHC.Base.Applicative [CodeGen.Codegen]
  = CodeGen.$fApplicativeCodegen
instance GHC.Base.Applicative [CodeGen.LLVM]
  = CodeGen.$fApplicativeLLVM
instance GHC.Base.Functor [CodeGen.Codegen]
  = CodeGen.$fFunctorCodegen
instance GHC.Base.Functor [CodeGen.LLVM] = CodeGen.$fFunctorLLVM
instance GHC.Base.Monad [CodeGen.Codegen] = CodeGen.$fMonadCodegen
instance GHC.Base.Monad [CodeGen.LLVM] = CodeGen.$fMonadLLVM
instance Control.Monad.State.Class.MonadState [CodeGen.CodegenState,
                                               CodeGen.Codegen]
  = CodeGen.$fMonadStateCodegen
instance Control.Monad.State.Class.MonadState [LLVM.AST.Module,
                                               CodeGen.LLVM]
  = CodeGen.$fMonadStateLLVM
instance GHC.Show.Show [CodeGen.BlockState]
  = CodeGen.$fShowBlockState
instance GHC.Show.Show [CodeGen.CodegenState]
  = CodeGen.$fShowCodegenState
"SPEC/CodeGen $fApplicativeStateT_$c<*> @ Identity _" [ALWAYS] forall @ s
                                                                      ($dMonad :: GHC.Base.Monad
                                                                                    Data.Functor.Identity.Identity)
                                                                      ($dFunctor :: GHC.Base.Functor
                                                                                      Data.Functor.Identity.Identity)
  Control.Monad.Trans.State.Lazy.$fApplicativeStateT_$c<*> @ Data.Functor.Identity.Identity
                                                           @ s
                                                           $dFunctor
                                                           $dMonad
  = CodeGen.$fApplicativeCodegen_$s$fApplicativeStateT_$c<*> @ s
"SPEC/CodeGen $fApplicativeStateT_$cpure @ Identity _" [ALWAYS] forall @ s
                                                                       ($dMonad :: GHC.Base.Monad
                                                                                     Data.Functor.Identity.Identity)
                                                                       ($dFunctor :: GHC.Base.Functor
                                                                                       Data.Functor.Identity.Identity)
  Control.Monad.Trans.State.Lazy.$fApplicativeStateT_$cpure @ Data.Functor.Identity.Identity
                                                            @ s
                                                            $dFunctor
                                                            $dMonad
  = CodeGen.$fApplicativeCodegen_$s$fApplicativeStateT_$cpure @ s
"SPEC/CodeGen $fFunctorStateT_$cfmap @ Identity _" [ALWAYS] forall @ s
                                                                   ($dFunctor :: GHC.Base.Functor
                                                                                   Data.Functor.Identity.Identity)
  Control.Monad.Trans.State.Lazy.$fFunctorStateT_$cfmap @ Data.Functor.Identity.Identity
                                                        @ s
                                                        $dFunctor
  = CodeGen.$fFunctorCodegen_$s$fFunctorStateT_$cfmap @ s
"SPEC/CodeGen $fMonadStateT_$c>> @ Identity _" [ALWAYS] forall @ s
                                                               ($dMonad :: GHC.Base.Monad
                                                                             Data.Functor.Identity.Identity)
  Control.Monad.Trans.State.Lazy.$fMonadStateT_$c>> @ Data.Functor.Identity.Identity
                                                    @ s
                                                    $dMonad
  = CodeGen.$fMonadCodegen_$s$fMonadStateT_$c>> @ s
"SPEC/CodeGen $fMonadStateT_$c>>= @ Identity _" [ALWAYS] forall @ s
                                                                ($dMonad :: GHC.Base.Monad
                                                                              Data.Functor.Identity.Identity)
  Control.Monad.Trans.State.Lazy.$fMonadStateT_$c>>= @ Data.Functor.Identity.Identity
                                                     @ s
                                                     $dMonad
  = CodeGen.$fMonadCodegen_$s$fMonadStateT_$c>>= @ s
"SPEC/CodeGen $fMonadStateT_$cfail @ Identity _" [ALWAYS] forall @ s
                                                                 ($dMonad :: GHC.Base.Monad
                                                                               Data.Functor.Identity.Identity)
  Control.Monad.Trans.State.Lazy.$fMonadStateT_$cfail @ Data.Functor.Identity.Identity
                                                      @ s
                                                      $dMonad
  = CodeGen.$fMonadCodegen_$s$fMonadStateT_$cfail @ s
"SPEC/CodeGen $fShowNamed @ Terminator" [ALWAYS] forall ($dShow :: GHC.Show.Show
                                                                     LLVM.AST.Instruction.Terminator)
  LLVM.AST.Instruction.$fShowNamed @ LLVM.AST.Instruction.Terminator
                                   $dShow
  = CodeGen.$s$fShowNamed
"SPEC/CodeGen $fShowNamed_$cshowList @ Terminator" [ALWAYS] forall ($dShow :: GHC.Show.Show
                                                                                LLVM.AST.Instruction.Terminator)
  LLVM.AST.Instruction.$fShowNamed_$cshowList @ LLVM.AST.Instruction.Terminator
                                              $dShow
  = CodeGen.$s$fShowNamed_$s$fShowNamed_$cshowList
"SPEC/CodeGen put @ Identity _" [ALWAYS] forall @ s
                                                ($dMonad :: GHC.Base.Monad
                                                              Data.Functor.Identity.Identity)
  Control.Monad.Trans.State.Lazy.put @ Data.Functor.Identity.Identity
                                     @ s
                                     $dMonad
  = CodeGen.$fMonadStateCodegen_$sput @ s
vectorised variables:
vectorised tycons:
vectorised reused tycons:
parallel variables:
parallel tycons:
trusted: none
require own pkg trusted: False

