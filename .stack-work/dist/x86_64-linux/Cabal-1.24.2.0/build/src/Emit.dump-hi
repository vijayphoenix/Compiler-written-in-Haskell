
==================== FINAL INTERFACE ====================
2019-04-25 17:53:04.861594 UTC

interface Haskull-0.1.0.0-BWrHz1hBGVfKvAfsCTzyaC:Emit 8002
  interface hash: 70b91579b98759f1e9d97c15c644aab0
  ABI hash: 2453edc61972e350596669442d7d430f
  export-list hash: 8ca71e957a049599e6a044cac87aee69
  orphan hash: 90958e91c83ec7bef59cf90678e3c36a
  flag hash: 1db610388c6802015371a3b99c5b5923
  sig of: Nothing
  used TH splices: False
  where
exports:
  Emit.addBlock
  Emit.binops
  Emit.call
  Emit.codegen
  Emit.codegenTop
  Emit.declarationGen
  Emit.exprGen
  Emit.externf
  Emit.fadd
  Emit.fdiv
  Emit.fmul
  Emit.fsub
  Emit.funcCallGen
  Emit.funcGen
  Emit.liftError
  Emit.literalGen
  Emit.toArgs
  Emit.varDeclGen
  Emit.varGen
module dependencies: AST CodeGen
package dependencies: array-0.5.1.1@array-0.5.1.1 base-4.9.1.0
                      binary-0.8.3.0@binary-0.8.3.0
                      bytestring-0.10.8.1@bytestring-0.10.8.1
                      containers-0.5.7.1@containers-0.5.7.1
                      deepseq-1.4.2.0@deepseq-1.4.2.0 ghc-boot-th-8.0.2@ghc-boot-th-8.0.2
                      ghc-prim-0.5.0.0 integer-gmp-1.0.0.1
                      llvm-hs-4.0.1.0@llvm-hs-4.0.1.0-7zNtSbHzHexJcgnwmG0bn2
                      llvm-hs-pure-4.0.0.0@llvm-hs-pure-4.0.0.0-2EKQPzemceCEww6fPxl71c
                      mtl-2.2.1@mtl-2.2.1-BLKBelFsPB3BoFeSWSOYj6
                      parsec-3.1.11@parsec-3.1.11-113irVHGgd88sRnywByDNw
                      pretty-1.1.3.3@pretty-1.1.3.3 template-haskell-2.11.1.0
                      text-1.2.2.1@text-1.2.2.1-Ji7hMs2U4BkBwavd4taEVR
                      transformers-0.5.2.0@transformers-0.5.2.0
                      utf8-string-1.0.1.1@utf8-string-1.0.1.1-1DpjxLeTvGg7ttZZojxJR5
orphans: base-4.9.1.0:GHC.Base base-4.9.1.0:GHC.Float
         binary-0.8.3.0@binary-0.8.3.0:Data.Binary.Generic
         bytestring-0.10.8.1@bytestring-0.10.8.1:Data.ByteString.Builder
         llvm-hs-4.0.1.0@llvm-hs-4.0.1.0-7zNtSbHzHexJcgnwmG0bn2:Control.Monad.AnyCont
         llvm-hs-4.0.1.0@llvm-hs-4.0.1.0-7zNtSbHzHexJcgnwmG0bn2:LLVM.Internal.Atomicity
         llvm-hs-4.0.1.0@llvm-hs-4.0.1.0-7zNtSbHzHexJcgnwmG0bn2:LLVM.Internal.Attribute
         llvm-hs-4.0.1.0@llvm-hs-4.0.1.0-7zNtSbHzHexJcgnwmG0bn2:LLVM.Internal.CallingConvention
         llvm-hs-4.0.1.0@llvm-hs-4.0.1.0-7zNtSbHzHexJcgnwmG0bn2:LLVM.Internal.Constant
         llvm-hs-4.0.1.0@llvm-hs-4.0.1.0-7zNtSbHzHexJcgnwmG0bn2:LLVM.Internal.EncodeAST
         llvm-hs-4.0.1.0@llvm-hs-4.0.1.0-7zNtSbHzHexJcgnwmG0bn2:LLVM.Internal.FFI.LLVMCTypes
         llvm-hs-4.0.1.0@llvm-hs-4.0.1.0-7zNtSbHzHexJcgnwmG0bn2:LLVM.Internal.FastMathFlags
         llvm-hs-4.0.1.0@llvm-hs-4.0.1.0-7zNtSbHzHexJcgnwmG0bn2:LLVM.Internal.FloatingPointPredicate
         llvm-hs-4.0.1.0@llvm-hs-4.0.1.0-7zNtSbHzHexJcgnwmG0bn2:LLVM.Internal.Global
         llvm-hs-4.0.1.0@llvm-hs-4.0.1.0-7zNtSbHzHexJcgnwmG0bn2:LLVM.Internal.InlineAssembly
         llvm-hs-4.0.1.0@llvm-hs-4.0.1.0-7zNtSbHzHexJcgnwmG0bn2:LLVM.Internal.Instruction
         llvm-hs-4.0.1.0@llvm-hs-4.0.1.0-7zNtSbHzHexJcgnwmG0bn2:LLVM.Internal.IntegerPredicate
         llvm-hs-4.0.1.0@llvm-hs-4.0.1.0-7zNtSbHzHexJcgnwmG0bn2:LLVM.Internal.MemoryBuffer
         llvm-hs-4.0.1.0@llvm-hs-4.0.1.0-7zNtSbHzHexJcgnwmG0bn2:LLVM.Internal.Metadata
         llvm-hs-4.0.1.0@llvm-hs-4.0.1.0-7zNtSbHzHexJcgnwmG0bn2:LLVM.Internal.Module
         llvm-hs-4.0.1.0@llvm-hs-4.0.1.0-7zNtSbHzHexJcgnwmG0bn2:LLVM.Internal.Operand
         llvm-hs-4.0.1.0@llvm-hs-4.0.1.0-7zNtSbHzHexJcgnwmG0bn2:LLVM.Internal.RMWOperation
         llvm-hs-4.0.1.0@llvm-hs-4.0.1.0-7zNtSbHzHexJcgnwmG0bn2:LLVM.Internal.String
         llvm-hs-4.0.1.0@llvm-hs-4.0.1.0-7zNtSbHzHexJcgnwmG0bn2:LLVM.Internal.TailCallKind
         llvm-hs-4.0.1.0@llvm-hs-4.0.1.0-7zNtSbHzHexJcgnwmG0bn2:LLVM.Internal.Target
         llvm-hs-4.0.1.0@llvm-hs-4.0.1.0-7zNtSbHzHexJcgnwmG0bn2:LLVM.Internal.Type
         text-1.2.2.1@text-1.2.2.1-Ji7hMs2U4BkBwavd4taEVR:Data.Text
         text-1.2.2.1@text-1.2.2.1-Ji7hMs2U4BkBwavd4taEVR:Data.Text.Lazy
         text-1.2.2.1@text-1.2.2.1-Ji7hMs2U4BkBwavd4taEVR:Data.Text.Show
         transformers-0.5.2.0@transformers-0.5.2.0:Control.Monad.Trans.Error
family instance modules: base-4.9.1.0:Control.Applicative
                         base-4.9.1.0:Data.Complex base-4.9.1.0:Data.Either
                         base-4.9.1.0:Data.Functor.Const base-4.9.1.0:Data.Functor.Identity
                         base-4.9.1.0:Data.List.NonEmpty base-4.9.1.0:Data.Monoid
                         base-4.9.1.0:Data.Semigroup base-4.9.1.0:Data.Type.Equality
                         base-4.9.1.0:Data.Version base-4.9.1.0:Data.Void
                         base-4.9.1.0:GHC.Exts base-4.9.1.0:GHC.Generics
                         base-4.9.1.0:GHC.IO.Exception base-4.9.1.0:GHC.TypeLits
                         containers-0.5.7.1@containers-0.5.7.1:Data.IntMap.Base
                         containers-0.5.7.1@containers-0.5.7.1:Data.IntSet.Base
                         containers-0.5.7.1@containers-0.5.7.1:Data.Map.Base
                         containers-0.5.7.1@containers-0.5.7.1:Data.Sequence
                         containers-0.5.7.1@containers-0.5.7.1:Data.Set.Base
                         ghc-boot-th-8.0.2@ghc-boot-th-8.0.2:GHC.LanguageExtensions.Type
                         pretty-1.1.3.3@pretty-1.1.3.3:Text.PrettyPrint.Annotated.HughesPJ
                         pretty-1.1.3.3@pretty-1.1.3.3:Text.PrettyPrint.HughesPJ
                         template-haskell-2.11.1.0:Language.Haskell.TH.Syntax
                         text-1.2.2.1@text-1.2.2.1-Ji7hMs2U4BkBwavd4taEVR:Data.Text
                         text-1.2.2.1@text-1.2.2.1-Ji7hMs2U4BkBwavd4taEVR:Data.Text.Lazy
import  -/  AST 7766b3f629d0c491c3020be7c559cd28
  exports: 5de5e88fd103c6732877d9f684527203
  Declaration 33d432a2601c6e2c29dde14013901097
  Divide 0d81982da38c3e2c9e4253505d9e8c87
  Expr af81e849342728200b6b013e210a8251
  ExternDecl 91d7bf81761177475f53629426cbe57c
  Func 901f27f2099af38bfcc39d4ad6579d8e
  Func 2c82732cb23ac10238193b154494d0d4
  FuncCall 2ad842676890cefc27a1bcae1ed12755
  FuncCall af81e849342728200b6b013e210a8251
  FuncCallStmt 989497f923f6d936b36ec4c41437c907
  IntLiteral 4b48d8e98df086d7aed64a2389e5eb6d
  Literal b8bb7416e10a99296972bf2d0a577a40
  LiteralStmt 8876a4eb88cc3ee5caf0a804c872faac
  Minus 31f32c7942b5a2f51f4d7a4695ea13fd
  Mul ab666f8b45526e36a68ce08c30ae7898
  Name 1259c2391d401e2b054e422bbb9873f0
  Plus 5853949815fae6aed92421e63e6911c4
  Type d08edfa29578fe246282f45c5f5b1a4f
  Var 5b3f2aeaf72873ae0ff963d4320813c0
import  -/  CodeGen 23d9a5f33de319117cec4ca4f04a712b
  exports: 3b43bfdc425c7d4b9de05bd0f34b7d2b
  Codegen d444e13d91ea16d54346634829ba461d
  LLVM 1d1e1a70335092265202f3dd4938f3fb
  addDef b70b67b14fe5133cfed95a961feb073b
  alloca 7a09c70bb1bc332075a0836044408925
  assign d953215e24497d3da11c4b1927858874
  blockCount e7d0189858a2d31fce3c4c276290cb14
  blocks 428672f9ad9904f7b98e2d72805864be
  createBlocks 60afa196427492de0f1957dbbeac5e76
  define 4ee7b0bf384edf4a10f5792e637f59a3
  emptyBlock 70223de8e9874eaf48e17cc39f984be4
  entryBlockName a66d2d9b30826c36c56862673b5df0fa
  execCodegen a195cdfda7d2849a82c58e4e202a3414
  getArgList 32ee015c3be344b24229eef7ae0b98b2
  getDef db7fde4237170a3cf915f6b31b8d126d
  getExtern 79efe6fb76526dbd1eb795ad96924c5c
  getName 4f97f17854f6b54244622f81396b90a8
  getType 6119272511ab106fe389fe8aa76856ab
  getvar 82533dc49ec446042fde2d7b8ff0be63
  instr a616ca62ae74077d377dcd93bd7510dc
  intL 3cc7ae9ae96297712bd68fbe36bdd00e
  load bb5a0c57a99b154152f55da79c9151c0
  local 66036a9923a3b76ccf8bd1f24ccbb5ed
  names d2b9c338d28c5fb7424732dbcece8c4f
  ret 79e0d932aecf137b091b7aa0e12513dc
  runLLVM 833fce218ae49848d26d7f01bc631a4b
  setBlock 8d50ed543f033220c1e5e58a3f6c9f14
  store 684a75d57455134eb85abd81f14d1638
  unikName e428722fa26c1ad952d3b6fddd1269a8
import  -/  base-4.9.1.0:Control.Applicative 32430a90492e727f4bd80db71c28600c
import  -/  base-4.9.1.0:Control.Monad a6784c5dab0d75c63dabec5a37843f98
import  -/  base-4.9.1.0:Data.Either 20b09ef8d0a5b74fdec011c40c1587f5
import  -/  base-4.9.1.0:Data.Traversable 556020d7cf3c4a34a774600512918a37
import  -/  base-4.9.1.0:Data.Tuple 7dc4bbb45d2e69c991ffac438beeca11
import  -/  base-4.9.1.0:GHC.Base c4231c43c07e46080a26bf94094c7aa1
import  -/  base-4.9.1.0:GHC.List ab8c4e523e6c479c549d3bcd5fc4a439
import  -/  base-4.9.1.0:GHC.Num 00bfaa7b2f9d6084913c0697a8a49ec8
import  -/  base-4.9.1.0:Prelude 22dd289b8469a8fa8dc81cab7b237771
import  -/  base-4.9.1.0:System.IO e4a64a8e3dce8616da54f0ee7104f7db
import  -/  containers-0.5.7.1@containers-0.5.7.1:Data.Map 20d4ffbee41965d03d6a989425473dc4
import  -/  containers-0.5.7.1@containers-0.5.7.1:Data.Map.Base d432f6875983131473086af8cb290590
import  -/  ghc-prim-0.5.0.0:GHC.Types 89f8de4f08018c9177c98d979eae0e45
import  -/  llvm-hs-4.0.1.0@llvm-hs-4.0.1.0-7zNtSbHzHexJcgnwmG0bn2:LLVM.Context 3ff979012af98bb0509b3c7237b2e52a
import  -/  llvm-hs-4.0.1.0@llvm-hs-4.0.1.0-7zNtSbHzHexJcgnwmG0bn2:LLVM.Internal.Context 023682cfe0edd228042dfab3a9581855
import  -/  llvm-hs-4.0.1.0@llvm-hs-4.0.1.0-7zNtSbHzHexJcgnwmG0bn2:LLVM.Internal.Module 2c382200082d479c225b1fd359f44adf
import  -/  llvm-hs-4.0.1.0@llvm-hs-4.0.1.0-7zNtSbHzHexJcgnwmG0bn2:LLVM.Module 177870c7e951c7d81f272cd33a027da8
import  -/  llvm-hs-pure-4.0.0.0@llvm-hs-pure-4.0.0.0-2EKQPzemceCEww6fPxl71c:LLVM.AST 47038b0f748769b63f8076369b1a33fb
import  -/  llvm-hs-pure-4.0.0.0@llvm-hs-pure-4.0.0.0-2EKQPzemceCEww6fPxl71c:LLVM.AST.Attribute eb81a8445bda21f72d298696f0386ab1
import  -/  llvm-hs-pure-4.0.0.0@llvm-hs-pure-4.0.0.0-2EKQPzemceCEww6fPxl71c:LLVM.AST.CallingConvention 898a3fa7d1a6c181bc1be149f6c494f0
import  -/  llvm-hs-pure-4.0.0.0@llvm-hs-pure-4.0.0.0-2EKQPzemceCEww6fPxl71c:LLVM.AST.Constant a78d56557db9674ef236577d1b57dc4a
import  -/  llvm-hs-pure-4.0.0.0@llvm-hs-pure-4.0.0.0-2EKQPzemceCEww6fPxl71c:LLVM.AST.Float 08df23a7019fe65998cb16e8349f5d71
import  -/  llvm-hs-pure-4.0.0.0@llvm-hs-pure-4.0.0.0-2EKQPzemceCEww6fPxl71c:LLVM.AST.FloatingPointPredicate f358b7bdbc6af687fc4359b85acfdc11
import  -/  llvm-hs-pure-4.0.0.0@llvm-hs-pure-4.0.0.0-2EKQPzemceCEww6fPxl71c:LLVM.AST.Instruction 7273bebee67e82826af4d75782172183
import  -/  llvm-hs-pure-4.0.0.0@llvm-hs-pure-4.0.0.0-2EKQPzemceCEww6fPxl71c:LLVM.AST.Name 3bf2310ba5c2808b0669a0beb60812ae
import  -/  llvm-hs-pure-4.0.0.0@llvm-hs-pure-4.0.0.0-2EKQPzemceCEww6fPxl71c:LLVM.AST.Operand 6c5218d5c26cd81924b6dad4be8916de
import  -/  llvm-hs-pure-4.0.0.0@llvm-hs-pure-4.0.0.0-2EKQPzemceCEww6fPxl71c:LLVM.AST.ParameterAttribute c4b7e7f11d1c9d5fcea04a537ab27c1c
import  -/  mtl-2.2.1@mtl-2.2.1-BLKBelFsPB3BoFeSWSOYj6:Control.Monad.Except 3bb0e2598193c1ba00c9723945e93004
import  -/  mtl-2.2.1@mtl-2.2.1-BLKBelFsPB3BoFeSWSOYj6:Control.Monad.State 749dca8ca0e6625b32091d445bd92b01
import  -/  mtl-2.2.1@mtl-2.2.1-BLKBelFsPB3BoFeSWSOYj6:Control.Monad.State.Class 6d31234b0a911b56412061943d18b89e
import  -/  transformers-0.5.2.0@transformers-0.5.2.0:Control.Monad.Trans.Except cf549ed58fbe6804d519833d92803f4c
8afc646445bf09ebd2544a04d835160a
  $sfromList :: [(AST.Op, a)] -> Data.Map.Base.Map AST.Op a
  {- Arity: 1, Strictness: <S,1*U>,
     Unfolding: (\ @ a (ds :: [(AST.Op, a)]) ->
                 case ds of wild {
                   [] -> Data.Map.Base.Tip @ AST.Op @ a
                   : ds1 ds2
                   -> case ds1 of wild1 { (,) kx x ->
                      case ds2 of wild2 {
                        []
                        -> case kx of dt { DEFAULT ->
                           Data.Map.Base.Bin
                             @ AST.Op
                             @ a
                             1#
                             dt
                             x
                             (Data.Map.Base.Tip @ AST.Op @ a)
                             (Data.Map.Base.Tip @ AST.Op @ a) }
                        : ipv ipv1
                        -> case ipv of wild3 { (,) ky ds3 ->
                           case kx of wild4 {
                             AST.Plus
                             -> case ky of wild5 {
                                  AST.Plus
                                  -> Emit.$sfromList1
                                       @ a
                                       (Data.Map.Base.Bin
                                          @ AST.Op
                                          @ a
                                          1#
                                          AST.Plus
                                          x
                                          (Data.Map.Base.Tip @ AST.Op @ a)
                                          (Data.Map.Base.Tip @ AST.Op @ a))
                                       wild2
                                  AST.Minus
                                  -> Emit.$wpoly_go10
                                       @ a
                                       1#
                                       (Data.Map.Base.Bin
                                          @ AST.Op
                                          @ a
                                          1#
                                          AST.Plus
                                          x
                                          (Data.Map.Base.Tip @ AST.Op @ a)
                                          (Data.Map.Base.Tip @ AST.Op @ a))
                                       wild2
                                  AST.Mul
                                  -> Emit.$wpoly_go10
                                       @ a
                                       1#
                                       (Data.Map.Base.Bin
                                          @ AST.Op
                                          @ a
                                          1#
                                          AST.Plus
                                          x
                                          (Data.Map.Base.Tip @ AST.Op @ a)
                                          (Data.Map.Base.Tip @ AST.Op @ a))
                                       wild2
                                  AST.Divide
                                  -> Emit.$wpoly_go10
                                       @ a
                                       1#
                                       (Data.Map.Base.Bin
                                          @ AST.Op
                                          @ a
                                          1#
                                          AST.Plus
                                          x
                                          (Data.Map.Base.Tip @ AST.Op @ a)
                                          (Data.Map.Base.Tip @ AST.Op @ a))
                                       wild2 }
                             AST.Minus
                             -> case ky of wild5 {
                                  DEFAULT
                                  -> Emit.$sfromList1
                                       @ a
                                       (Data.Map.Base.Bin
                                          @ AST.Op
                                          @ a
                                          1#
                                          AST.Minus
                                          x
                                          (Data.Map.Base.Tip @ AST.Op @ a)
                                          (Data.Map.Base.Tip @ AST.Op @ a))
                                       wild2
                                  AST.Mul
                                  -> Emit.$wpoly_go10
                                       @ a
                                       1#
                                       (Data.Map.Base.Bin
                                          @ AST.Op
                                          @ a
                                          1#
                                          AST.Minus
                                          x
                                          (Data.Map.Base.Tip @ AST.Op @ a)
                                          (Data.Map.Base.Tip @ AST.Op @ a))
                                       wild2
                                  AST.Divide
                                  -> Emit.$wpoly_go10
                                       @ a
                                       1#
                                       (Data.Map.Base.Bin
                                          @ AST.Op
                                          @ a
                                          1#
                                          AST.Minus
                                          x
                                          (Data.Map.Base.Tip @ AST.Op @ a)
                                          (Data.Map.Base.Tip @ AST.Op @ a))
                                       wild2 }
                             AST.Mul
                             -> case ky of wild5 {
                                  DEFAULT
                                  -> Emit.$sfromList1
                                       @ a
                                       (Data.Map.Base.Bin
                                          @ AST.Op
                                          @ a
                                          1#
                                          AST.Mul
                                          x
                                          (Data.Map.Base.Tip @ AST.Op @ a)
                                          (Data.Map.Base.Tip @ AST.Op @ a))
                                       wild2
                                  AST.Divide
                                  -> Emit.$wpoly_go10
                                       @ a
                                       1#
                                       (Data.Map.Base.Bin
                                          @ AST.Op
                                          @ a
                                          1#
                                          AST.Mul
                                          x
                                          (Data.Map.Base.Tip @ AST.Op @ a)
                                          (Data.Map.Base.Tip @ AST.Op @ a))
                                       wild2 }
                             AST.Divide
                             -> case ky of wild5 { DEFAULT ->
                                Emit.$sfromList1
                                  @ a
                                  (Data.Map.Base.Bin
                                     @ AST.Op
                                     @ a
                                     1#
                                     AST.Divide
                                     x
                                     (Data.Map.Base.Tip @ AST.Op @ a)
                                     (Data.Map.Base.Tip @ AST.Op @ a))
                                  wild2 } } } } } }) -}
a429c466dc29053cf062fe01af91497e
  $sfromList1 ::
    Data.Map.Base.Map AST.Op a1
    -> [(AST.Op, a1)] -> Data.Map.Base.Map AST.Op a1
  {- Arity: 2, Strictness: <S,1*U><S,1*U> -}
3af1c1dacca09f61fe384fd67fc12c87
  $sinsert_$sgo1 ::
    AST.Op
    -> a1 -> Data.Map.Base.Map AST.Op a1 -> Data.Map.Base.Map AST.Op a1
  {- Arity: 3, Strictness: <S,1*U><L,U><S,1*U> -}
54cac4bf3857d16b2865738112429b0e
  $sinsert_$sgo10 ::
    LLVM.AST.Name.Name
    -> a1
    -> Data.Map.Base.Map LLVM.AST.Name.Name a1
    -> Data.Map.Base.Map LLVM.AST.Name.Name a1
  {- Arity: 3, Strictness: <S,1*U><L,U><S,1*U> -}
923fdc24af44823fe3de6861d0a384ff
  $trModule :: GHC.Types.Module
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.Module Emit.$trModule2 Emit.$trModule1) -}
0a36676306408b0e33c2f822c5403bd0
  $trModule1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS "Emit"#) -}
a65503ddd95063af3dd7a6f36b36bbcf
  $trModule2 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS
                   "Haskull-0.1.0.0-BWrHz1hBGVfKvAfsCTzyaC"#) -}
ffcf9b61353f3f3c663e241db69956f8
  $waddBlock ::
    GHC.Base.String
    -> CodeGen.CodegenState
    -> (# LLVM.AST.Name.Name, CodeGen.CodegenState #)
  {- Arity: 2, Strictness: <L,U><L,U(U,1*U,U,U(U),U,U)>, Inline: [0],
     Unfolding: (\ (w :: GHC.Base.String)
                   (w1 :: CodeGen.CodegenState) ->
                 let {
                   ds :: (GHC.Base.String, CodeGen.Names)
                   = case w1 of wild { CodeGen.CodegenState ds1 ds2 ds3 ds4 ds5 ds6 ->
                     case CodeGen.$wunikName w ds6 of ww { (#,#) ww1 ww2 ->
                     (ww1, ww2) } }
                 } in
                 let {
                   qname :: GHC.Base.String
                   = case ds of wild { (,) qname1 supply -> qname1 }
                 } in
                 (# LLVM.AST.Name.Name qname,
                    case w1 of wild { CodeGen.CodegenState ds1 ds2 ds3 ds4 ds5 ds6 ->
                    CodeGen.CodegenState
                      ds1
                      (Emit.$sinsert_$sgo10
                         @ CodeGen.BlockState
                         (LLVM.AST.Name.Name qname)
                         (CodeGen.BlockState
                            ds4
                            (GHC.Types.[]
                               @ (LLVM.AST.Instruction.Named LLVM.AST.Instruction.Instruction))
                            (GHC.Base.Nothing
                               @ (LLVM.AST.Instruction.Named LLVM.AST.Instruction.Terminator)))
                         ds2)
                      ds3
                      (case ds4 of wild1 { GHC.Types.I# x ->
                       GHC.Types.I# (GHC.Prim.+# x 1#) })
                      ds5
                      (case ds of wild1 { (,) qname1 supply -> supply }) } #)) -}
679689bf29a5d99ab3075a6ab5078cdf
  $wcodegenTop ::
    AST.Name
    -> AST.ArgList -> AST.Type -> [AST.Expr] -> CodeGen.LLVM ()
  {- Arity: 4, Strictness: <L,U><L,U><L,1*U><L,1*U>, Inline: [0],
     Unfolding: (\ (ww :: AST.Name)
                   (ww1 :: AST.ArgList)
                   (ww2 :: AST.Type)
                   (ww3 :: [AST.Expr]) ->
                 CodeGen.define
                   (CodeGen.getType ww2)
                   ww
                   (GHC.Base.map
                      @ (AST.Type, AST.Name)
                      @ (LLVM.AST.Type.Type, LLVM.AST.Name.Name)
                      CodeGen.getArgList1
                      ww1)
                   (let {
                      ds :: Data.Functor.Identity.Identity
                              (LLVM.AST.Operand.Operand, CodeGen.CodegenState)
                      = case GHC.List.$w!! @ AST.Expr ww3 0# of wild {
                          DEFAULT
                          -> case Emit.codegenTop8
                             ret_ty (Data.Functor.Identity.Identity
                                       (LLVM.AST.Operand.Operand, CodeGen.CodegenState))
                             of {}
                          AST.Var x
                          -> let {
                               ds1 :: Data.Functor.Identity.Identity
                                        (LLVM.AST.Operand.Operand, CodeGen.CodegenState)
                               = case Emit.$wgo1 ww1 Emit.codegenTop1 of ww4 { (#,#) ww5 ww6 ->
                                 case ww6 of ww7 { CodeGen.CodegenState ww8 ww9 ww10 ww11 ww12 ww13 ->
                                 case GHC.List.lookup
                                        @ GHC.Base.String
                                        @ LLVM.AST.Operand.Operand
                                        GHC.Classes.$fEq[]_$s$fEq[]1
                                        x
                                        ww10 of wild1 {
                                   GHC.Base.Nothing
                                   -> case CodeGen.getvar2 x
                                      ret_ty (Data.Functor.Identity.Identity
                                                (LLVM.AST.Operand.Operand, CodeGen.CodegenState))
                                      of {}
                                   GHC.Base.Just x1
                                   -> (x1, ww7)
                                        `cast`
                                      (Sym (Data.Functor.Identity.N:Identity[0]
                                                <(LLVM.AST.Operand.Operand,
                                                  CodeGen.CodegenState)>_R)) } } }
                             } in
                             case CodeGen.$winstr
                                    (LLVM.AST.Instruction.Load
                                       GHC.Types.False
                                       (case ds1
                                               `cast`
                                             (Data.Functor.Identity.N:Identity[0]
                                                  <(LLVM.AST.Operand.Operand,
                                                    CodeGen.CodegenState)>_R) of wild1 { (,) a1 s' ->
                                        a1 })
                                       (GHC.Base.Nothing @ LLVM.AST.Instruction.Atomicity)
                                       CodeGen.alloca2
                                       (GHC.Types.[]
                                          @ (GHC.Base.String, LLVM.AST.Operand.MetadataNode)))
                                    (case ds1
                                            `cast`
                                          (Data.Functor.Identity.N:Identity[0]
                                               <(LLVM.AST.Operand.Operand,
                                                 CodeGen.CodegenState)>_R) of wild1 { (,) a1 s' ->
                                     s' }) of ww4 { (#,#) ww5 ww6 ->
                             (ww5, ww6)
                               `cast`
                             (Sym (Data.Functor.Identity.N:Identity[0]
                                       <(LLVM.AST.Operand.Operand, CodeGen.CodegenState)>_R)) } }
                    } in
                    case CodeGen.$wterminator
                           (LLVM.AST.Instruction.Do
                              @ LLVM.AST.Instruction.Terminator
                              (LLVM.AST.Instruction.Ret
                                 (GHC.Base.Just
                                    @ LLVM.AST.Operand.Operand
                                    (case ds
                                            `cast`
                                          (Data.Functor.Identity.N:Identity[0]
                                               <(LLVM.AST.Operand.Operand,
                                                 CodeGen.CodegenState)>_R) of wild { (,) a1 s' ->
                                     a1 }))
                                 (GHC.Types.[] @ (GHC.Base.String, LLVM.AST.Operand.MetadataNode))))
                           (case ds
                                   `cast`
                                 (Data.Functor.Identity.N:Identity[0]
                                      <(LLVM.AST.Operand.Operand,
                                        CodeGen.CodegenState)>_R) of wild { (,) a1 s' ->
                            s' }) of ww4 { (#,#) ww5 ww6 ->
                    CodeGen.createBlocks ww6 })) -}
20695a560bd35f18678d31860c13862d
  $wfuncCallGen ::
    AST.Name -> AST.Args -> CodeGen.Codegen LLVM.AST.Operand.Operand
  {- Arity: 2, Strictness: <L,U><L,1*U>, Inline: [0],
     Unfolding: (\ (ww :: AST.Name) (ww1 :: AST.Args) ->
                 let {
                   m1 :: CodeGen.Codegen [LLVM.AST.Operand.Operand]
                   = Emit.funcCallGen_go ww1
                 } in
                 let {
                   lvl :: LLVM.AST.Name.Name = LLVM.AST.Name.Name ww
                 } in
                 let {
                   lvl1 :: LLVM.AST.Constant.Constant
                   = LLVM.AST.Constant.GlobalReference CodeGen.intL lvl
                 } in
                 let {
                   lvl2 :: LLVM.AST.Operand.Operand
                   = LLVM.AST.Operand.ConstantOperand lvl1
                 } in
                 let {
                   lvl3 :: Data.Either.Either
                             LLVM.AST.InlineAssembly.InlineAssembly LLVM.AST.Operand.Operand
                   = Data.Either.Right
                       @ LLVM.AST.InlineAssembly.InlineAssembly
                       @ LLVM.AST.Operand.Operand
                       lvl2
                 } in
                 (\ (s1 :: CodeGen.CodegenState) ->
                  let {
                    ds :: Data.Functor.Identity.Identity
                            ([LLVM.AST.Operand.Operand], CodeGen.CodegenState)
                    = m1
                        `cast`
                      (Trans
                           (CodeGen.N:Codegen[0] <[LLVM.AST.Operand.Operand]>_N)
                           (Control.Monad.Trans.State.Lazy.N:StateT[0]
                                <CodeGen.CodegenState>_N
                                <Data.Functor.Identity.Identity>_R
                                <[LLVM.AST.Operand.Operand]>_N))
                        s1
                  } in
                  case CodeGen.$winstr
                         (LLVM.AST.Instruction.Call
                            (GHC.Base.Nothing @ LLVM.AST.Instruction.TailCallKind)
                            LLVM.AST.CallingConvention.C
                            (GHC.Types.[] @ LLVM.AST.ParameterAttribute.ParameterAttribute)
                            lvl3
                            (case ds
                                    `cast`
                                  (Data.Functor.Identity.N:Identity[0]
                                       <([LLVM.AST.Operand.Operand],
                                         CodeGen.CodegenState)>_R) of wild { (,) a1 s' ->
                             GHC.Base.map
                               @ LLVM.AST.Operand.Operand
                               @ (LLVM.AST.Operand.Operand,
                                  [LLVM.AST.ParameterAttribute.ParameterAttribute])
                               Emit.call2
                               a1 })
                            (GHC.Types.[]
                               @ (Data.Either.Either
                                    LLVM.AST.FunctionAttribute.GroupID
                                    LLVM.AST.FunctionAttribute.FunctionAttribute))
                            (GHC.Types.[] @ (GHC.Base.String, LLVM.AST.Operand.MetadataNode)))
                         (case ds
                                 `cast`
                               (Data.Functor.Identity.N:Identity[0]
                                    <([LLVM.AST.Operand.Operand],
                                      CodeGen.CodegenState)>_R) of wild { (,) a1 s' ->
                          s' }) of ww2 { (#,#) ww3 ww4 ->
                  (ww3, ww4)
                    `cast`
                  (Sym (Data.Functor.Identity.N:Identity[0]
                            <(LLVM.AST.Operand.Operand, CodeGen.CodegenState)>_R)) })
                   `cast`
                 (Trans
                      (Sym (Control.Monad.Trans.State.Lazy.N:StateT[0]
                                <CodeGen.CodegenState>_N
                                <Data.Functor.Identity.Identity>_R
                                <LLVM.AST.Operand.Operand>_N))
                      (Sym (CodeGen.N:Codegen[0]) <LLVM.AST.Operand.Operand>_N))) -}
ebfab9f3ba391e95cae1645777ce824e
  $wgo ::
    [AST.Func] -> LLVM.AST.Module -> (# [()], LLVM.AST.Module #)
  {- Arity: 2, Strictness: <S,1*U><L,U>, Inline: [0] -}
653c938ad6be687276ffd08e0a764d40
  $wgo1 ::
    [(AST.Type, AST.Name)]
    -> CodeGen.CodegenState -> (# [()], CodeGen.CodegenState #)
  {- Arity: 2, Strictness: <S,1*U><L,U(U,U,U,U,U(U),U)>,
     Inline: [0] -}
c90eb6c0c323b5f412fdfb9300ac6dcb
  $wpoly_go10 ::
    GHC.Prim.Int#
    -> Data.Map.Base.Map AST.Op a
    -> [(AST.Op, a)]
    -> Data.Map.Base.Map AST.Op a
  {- Arity: 3, Strictness: <L,U><S,1*U><S,1*U>, Inline: [0] -}
1a9ea1612419948b00d2e8c80b5c6a3b
  $wvarDeclGen ::
    (AST.Type, AST.Name)
    -> CodeGen.CodegenState -> (# (), CodeGen.CodegenState #)
  {- Arity: 2, Strictness: <L,U(1*U,U)><L,U(U,U,U,U,U(U),U)>,
     Inline: [0],
     Unfolding: (\ (w :: (AST.Type, AST.Name))
                   (w1 :: CodeGen.CodegenState) ->
                 (# GHC.Tuple.(),
                    let {
                      ds :: Data.Functor.Identity.Identity
                              (LLVM.AST.Operand.Operand, CodeGen.CodegenState)
                      = case CodeGen.$winstr
                               (LLVM.AST.Instruction.Alloca
                                  (case w of wild { (,) x ds1 ->
                                   case x of wild1 {
                                     AST.IntC -> CodeGen.intL
                                     AST.StringC -> CodeGen.getArgList2 } })
                                  (GHC.Base.Nothing @ LLVM.AST.Operand.Operand)
                                  CodeGen.alloca2
                                  (GHC.Types.[] @ (GHC.Base.String, LLVM.AST.Operand.MetadataNode)))
                               w1 of ww { (#,#) ww1 ww2 ->
                        (ww1, ww2)
                          `cast`
                        (Sym (Data.Functor.Identity.N:Identity[0]
                                  <(LLVM.AST.Operand.Operand, CodeGen.CodegenState)>_R)) }
                    } in
                    let {
                      var :: LLVM.AST.Operand.Operand
                      = case ds
                               `cast`
                             (Data.Functor.Identity.N:Identity[0]
                                  <(LLVM.AST.Operand.Operand,
                                    CodeGen.CodegenState)>_R) of wild { (,) a1 s' ->
                        a1 }
                    } in
                    case CodeGen.$winstr
                           (LLVM.AST.Instruction.Store
                              GHC.Types.False
                              var
                              (LLVM.AST.Operand.LocalReference
                                 LLVM.AST.Type.double
                                 (LLVM.AST.Name.Name (case w of wild { (,) ds1 y -> y })))
                              (GHC.Base.Nothing @ LLVM.AST.Instruction.Atomicity)
                              CodeGen.alloca2
                              (GHC.Types.[] @ (GHC.Base.String, LLVM.AST.Operand.MetadataNode)))
                           (case ds
                                   `cast`
                                 (Data.Functor.Identity.N:Identity[0]
                                      <(LLVM.AST.Operand.Operand,
                                        CodeGen.CodegenState)>_R) of wild { (,) a1 s' ->
                            s' }) of ww { (#,#) ww1 ww2 ->
                    case ww2 of wild { CodeGen.CodegenState ds1 ds2 ds3 ds4 ds5 ds6 ->
                    CodeGen.CodegenState
                      ds1
                      ds2
                      (GHC.Types.:
                         @ (GHC.Base.String, LLVM.AST.Operand.Operand)
                         (case w of wild1 { (,) ds7 y -> y }, var)
                         ds3)
                      ds4
                      ds5
                      ds6 } } #)) -}
f3f50d76f60275f20adf643b1ab5391b
  $wvarGen ::
    AST.Expr
    -> CodeGen.CodegenState
    -> (# LLVM.AST.Operand.Operand, CodeGen.CodegenState #)
  {- Arity: 2, Strictness: <S,1*U><L,1*U(U,U,U,U,U,U)>, Inline: [0],
     Unfolding: (\ (w :: AST.Expr) (w1 :: CodeGen.CodegenState) ->
                 case w of wild {
                   DEFAULT
                   -> case Emit.codegenTop8
                      ret_ty (# LLVM.AST.Operand.Operand, CodeGen.CodegenState #)
                      of {}
                   AST.Var x
                   -> let {
                        ds :: Data.Functor.Identity.Identity
                                (LLVM.AST.Operand.Operand, CodeGen.CodegenState)
                        = case w1 of ww { CodeGen.CodegenState ww1 ww2 ww3 ww4 ww5 ww6 ->
                          case GHC.List.lookup
                                 @ GHC.Base.String
                                 @ LLVM.AST.Operand.Operand
                                 GHC.Classes.$fEq[]_$s$fEq[]1
                                 x
                                 ww3 of wild1 {
                            GHC.Base.Nothing
                            -> case CodeGen.getvar2 x
                               ret_ty (Data.Functor.Identity.Identity
                                         (LLVM.AST.Operand.Operand, CodeGen.CodegenState))
                               of {}
                            GHC.Base.Just x1
                            -> (x1, ww)
                                 `cast`
                               (Sym (Data.Functor.Identity.N:Identity[0]
                                         <(LLVM.AST.Operand.Operand, CodeGen.CodegenState)>_R)) } }
                      } in
                      CodeGen.$winstr
                        (LLVM.AST.Instruction.Load
                           GHC.Types.False
                           (case ds
                                   `cast`
                                 (Data.Functor.Identity.N:Identity[0]
                                      <(LLVM.AST.Operand.Operand,
                                        CodeGen.CodegenState)>_R) of wild1 { (,) a1 s' ->
                            a1 })
                           (GHC.Base.Nothing @ LLVM.AST.Instruction.Atomicity)
                           CodeGen.alloca2
                           (GHC.Types.[] @ (GHC.Base.String, LLVM.AST.Operand.MetadataNode)))
                        (case ds
                                `cast`
                              (Data.Functor.Identity.N:Identity[0]
                                   <(LLVM.AST.Operand.Operand,
                                     CodeGen.CodegenState)>_R) of wild1 { (,) a1 s' ->
                         s' }) }) -}
a3848f78e260e2eaef979cf8cc729393
  addBlock :: GHC.Base.String -> CodeGen.Codegen LLVM.AST.Name.Name
  {- Arity: 2, Strictness: <L,U><L,U(U,1*U,U,U(U),U,U)>m,
     Unfolding: InlineRule (0, True, True)
                Emit.addBlock1
                  `cast`
                (<GHC.Base.String>_R
                 ->_R Trans
                          (Sym (Control.Monad.Trans.State.Lazy.N:StateT[0]
                                    <CodeGen.CodegenState>_N
                                    <Data.Functor.Identity.Identity>_R
                                    <LLVM.AST.Name.Name>_N))
                          (Sym (CodeGen.N:Codegen[0]) <LLVM.AST.Name.Name>_N)) -}
4b2d62d7a18b5584723d520a5780b302
  addBlock1 ::
    GHC.Base.String
    -> CodeGen.CodegenState
    -> Data.Functor.Identity.Identity
         (LLVM.AST.Name.Name, CodeGen.CodegenState)
  {- Arity: 2, Strictness: <L,U><L,U(U,1*U,U,U(U),U,U)>m,
     Inline: INLINE[0],
     Unfolding: InlineRule (2, True, False)
                (\ (w :: GHC.Base.String) (w1 :: CodeGen.CodegenState) ->
                 case Emit.$waddBlock w w1 of ww { (#,#) ww1 ww2 ->
                 (ww1, ww2)
                   `cast`
                 (Sym (Data.Functor.Identity.N:Identity[0]
                           <(LLVM.AST.Name.Name, CodeGen.CodegenState)>_R)) }) -}
ac0eb9799c7b62227ef9abd914747bfb
  binops ::
    Data.Map.Base.Map
      AST.Op
      (LLVM.AST.Operand.Operand
       -> LLVM.AST.Operand.Operand
       -> CodeGen.Codegen LLVM.AST.Operand.Operand)
  {- Unfolding: (Emit.$sfromList
                   @ (LLVM.AST.Operand.Operand
                      -> LLVM.AST.Operand.Operand
                      -> CodeGen.Codegen LLVM.AST.Operand.Operand)
                   Emit.binops1) -}
11a586700dd12e9bcc3797fd61001d64
  binops1 ::
    [(AST.Op,
      LLVM.AST.Operand.Operand
      -> LLVM.AST.Operand.Operand
      -> CodeGen.Codegen LLVM.AST.Operand.Operand)]
  {- Unfolding: (GHC.Types.:
                   @ (AST.Op,
                      LLVM.AST.Operand.Operand
                      -> LLVM.AST.Operand.Operand
                      -> CodeGen.Codegen LLVM.AST.Operand.Operand)
                   Emit.binops11
                   Emit.binops2) -}
c3c5698d048036f88a6a18c4ef55cc1c
  binops10 ::
    LLVM.AST.Operand.Operand
    -> LLVM.AST.Operand.Operand
    -> CodeGen.CodegenState
    -> Data.Functor.Identity.Identity
         (LLVM.AST.Operand.Operand, CodeGen.CodegenState)
  {- Arity: 3, Strictness: <L,U><L,U><L,U(U,U,U,U,U(U),U)>m,
     Unfolding: InlineRule (3, True, False)
                (\ (a :: LLVM.AST.Operand.Operand)
                   (b :: LLVM.AST.Operand.Operand)
                   (eta :: CodeGen.CodegenState) ->
                 case CodeGen.$winstr
                        (LLVM.AST.Instruction.FSub
                           LLVM.AST.Instruction.NoFastMathFlags
                           a
                           b
                           (GHC.Types.[] @ (GHC.Base.String, LLVM.AST.Operand.MetadataNode)))
                        eta of ww { (#,#) ww1 ww2 ->
                 (ww1, ww2)
                   `cast`
                 (Sym (Data.Functor.Identity.N:Identity[0]
                           <(LLVM.AST.Operand.Operand, CodeGen.CodegenState)>_R)) }) -}
ce77cbcfbf5a427ec9d06006ecbbc638
  binops11 ::
    (AST.Op,
     LLVM.AST.Operand.Operand
     -> LLVM.AST.Operand.Operand
     -> CodeGen.Codegen LLVM.AST.Operand.Operand)
  {- Unfolding: ((AST.Plus,
                  Emit.binops12
                    `cast`
                  (<LLVM.AST.Operand.Operand>_R
                   ->_R <LLVM.AST.Operand.Operand>_R
                   ->_R Trans
                            (Sym (Control.Monad.Trans.State.Lazy.N:StateT[0]
                                      <CodeGen.CodegenState>_N
                                      <Data.Functor.Identity.Identity>_R
                                      <LLVM.AST.Operand.Operand>_N))
                            (Sym (CodeGen.N:Codegen[0]) <LLVM.AST.Operand.Operand>_N)))) -}
adb94ddf4ff54d1b6826faaf4b000199
  binops12 ::
    LLVM.AST.Operand.Operand
    -> LLVM.AST.Operand.Operand
    -> CodeGen.CodegenState
    -> Data.Functor.Identity.Identity
         (LLVM.AST.Operand.Operand, CodeGen.CodegenState)
  {- Arity: 3, Strictness: <L,U><L,U><L,U(U,U,U,U,U(U),U)>m,
     Unfolding: InlineRule (3, True, False)
                (\ (a :: LLVM.AST.Operand.Operand)
                   (b :: LLVM.AST.Operand.Operand)
                   (eta :: CodeGen.CodegenState) ->
                 case CodeGen.$winstr
                        (LLVM.AST.Instruction.FAdd
                           LLVM.AST.Instruction.NoFastMathFlags
                           a
                           b
                           (GHC.Types.[] @ (GHC.Base.String, LLVM.AST.Operand.MetadataNode)))
                        eta of ww { (#,#) ww1 ww2 ->
                 (ww1, ww2)
                   `cast`
                 (Sym (Data.Functor.Identity.N:Identity[0]
                           <(LLVM.AST.Operand.Operand, CodeGen.CodegenState)>_R)) }) -}
9fe860e1fe587e84eda88ec31441e1db
  binops2 ::
    [(AST.Op,
      LLVM.AST.Operand.Operand
      -> LLVM.AST.Operand.Operand
      -> CodeGen.Codegen LLVM.AST.Operand.Operand)]
  {- Unfolding: (GHC.Types.:
                   @ (AST.Op,
                      LLVM.AST.Operand.Operand
                      -> LLVM.AST.Operand.Operand
                      -> CodeGen.Codegen LLVM.AST.Operand.Operand)
                   Emit.binops9
                   Emit.binops3) -}
a4a8f699893cbd52db81d32ab9b9fc80
  binops3 ::
    [(AST.Op,
      LLVM.AST.Operand.Operand
      -> LLVM.AST.Operand.Operand
      -> CodeGen.Codegen LLVM.AST.Operand.Operand)]
  {- Unfolding: (GHC.Types.:
                   @ (AST.Op,
                      LLVM.AST.Operand.Operand
                      -> LLVM.AST.Operand.Operand
                      -> CodeGen.Codegen LLVM.AST.Operand.Operand)
                   Emit.binops7
                   Emit.binops4) -}
10d21875d6371dffee54cda62a22fa35
  binops4 ::
    [(AST.Op,
      LLVM.AST.Operand.Operand
      -> LLVM.AST.Operand.Operand
      -> CodeGen.Codegen LLVM.AST.Operand.Operand)]
  {- Unfolding: (GHC.Types.:
                   @ (AST.Op,
                      LLVM.AST.Operand.Operand
                      -> LLVM.AST.Operand.Operand
                      -> CodeGen.Codegen LLVM.AST.Operand.Operand)
                   Emit.binops5
                   (GHC.Types.[]
                      @ (AST.Op,
                         LLVM.AST.Operand.Operand
                         -> LLVM.AST.Operand.Operand
                         -> CodeGen.Codegen LLVM.AST.Operand.Operand))) -}
b573b6eb2207f738f1bdf50e32012a86
  binops5 ::
    (AST.Op,
     LLVM.AST.Operand.Operand
     -> LLVM.AST.Operand.Operand
     -> CodeGen.Codegen LLVM.AST.Operand.Operand)
  {- Unfolding: ((AST.Divide,
                  Emit.binops6
                    `cast`
                  (<LLVM.AST.Operand.Operand>_R
                   ->_R <LLVM.AST.Operand.Operand>_R
                   ->_R Trans
                            (Sym (Control.Monad.Trans.State.Lazy.N:StateT[0]
                                      <CodeGen.CodegenState>_N
                                      <Data.Functor.Identity.Identity>_R
                                      <LLVM.AST.Operand.Operand>_N))
                            (Sym (CodeGen.N:Codegen[0]) <LLVM.AST.Operand.Operand>_N)))) -}
a756f73c0538a30d67dce783e0dced3c
  binops6 ::
    LLVM.AST.Operand.Operand
    -> LLVM.AST.Operand.Operand
    -> CodeGen.CodegenState
    -> Data.Functor.Identity.Identity
         (LLVM.AST.Operand.Operand, CodeGen.CodegenState)
  {- Arity: 3, Strictness: <L,U><L,U><L,U(U,U,U,U,U(U),U)>m,
     Unfolding: InlineRule (3, True, False)
                (\ (a :: LLVM.AST.Operand.Operand)
                   (b :: LLVM.AST.Operand.Operand)
                   (eta :: CodeGen.CodegenState) ->
                 case CodeGen.$winstr
                        (LLVM.AST.Instruction.FDiv
                           LLVM.AST.Instruction.NoFastMathFlags
                           a
                           b
                           (GHC.Types.[] @ (GHC.Base.String, LLVM.AST.Operand.MetadataNode)))
                        eta of ww { (#,#) ww1 ww2 ->
                 (ww1, ww2)
                   `cast`
                 (Sym (Data.Functor.Identity.N:Identity[0]
                           <(LLVM.AST.Operand.Operand, CodeGen.CodegenState)>_R)) }) -}
242c9016351da31ec30af63f17eda50c
  binops7 ::
    (AST.Op,
     LLVM.AST.Operand.Operand
     -> LLVM.AST.Operand.Operand
     -> CodeGen.Codegen LLVM.AST.Operand.Operand)
  {- Unfolding: ((AST.Mul,
                  Emit.binops8
                    `cast`
                  (<LLVM.AST.Operand.Operand>_R
                   ->_R <LLVM.AST.Operand.Operand>_R
                   ->_R Trans
                            (Sym (Control.Monad.Trans.State.Lazy.N:StateT[0]
                                      <CodeGen.CodegenState>_N
                                      <Data.Functor.Identity.Identity>_R
                                      <LLVM.AST.Operand.Operand>_N))
                            (Sym (CodeGen.N:Codegen[0]) <LLVM.AST.Operand.Operand>_N)))) -}
fc790cd0ec33a3d6fa6e13edbcb81cc9
  binops8 ::
    LLVM.AST.Operand.Operand
    -> LLVM.AST.Operand.Operand
    -> CodeGen.CodegenState
    -> Data.Functor.Identity.Identity
         (LLVM.AST.Operand.Operand, CodeGen.CodegenState)
  {- Arity: 3, Strictness: <L,U><L,U><L,U(U,U,U,U,U(U),U)>m,
     Unfolding: InlineRule (3, True, False)
                (\ (a :: LLVM.AST.Operand.Operand)
                   (b :: LLVM.AST.Operand.Operand)
                   (eta :: CodeGen.CodegenState) ->
                 case CodeGen.$winstr
                        (LLVM.AST.Instruction.FMul
                           LLVM.AST.Instruction.NoFastMathFlags
                           a
                           b
                           (GHC.Types.[] @ (GHC.Base.String, LLVM.AST.Operand.MetadataNode)))
                        eta of ww { (#,#) ww1 ww2 ->
                 (ww1, ww2)
                   `cast`
                 (Sym (Data.Functor.Identity.N:Identity[0]
                           <(LLVM.AST.Operand.Operand, CodeGen.CodegenState)>_R)) }) -}
39b8618a447077c5e8368e4a812e3295
  binops9 ::
    (AST.Op,
     LLVM.AST.Operand.Operand
     -> LLVM.AST.Operand.Operand
     -> CodeGen.Codegen LLVM.AST.Operand.Operand)
  {- Unfolding: ((AST.Minus,
                  Emit.binops10
                    `cast`
                  (<LLVM.AST.Operand.Operand>_R
                   ->_R <LLVM.AST.Operand.Operand>_R
                   ->_R Trans
                            (Sym (Control.Monad.Trans.State.Lazy.N:StateT[0]
                                      <CodeGen.CodegenState>_N
                                      <Data.Functor.Identity.Identity>_R
                                      <LLVM.AST.Operand.Operand>_N))
                            (Sym (CodeGen.N:Codegen[0]) <LLVM.AST.Operand.Operand>_N)))) -}
849a7fc4029cf9132c78af7c891b8cea
  call ::
    LLVM.AST.Operand.Operand
    -> [LLVM.AST.Operand.Operand]
    -> CodeGen.Codegen LLVM.AST.Operand.Operand
  {- Arity: 2, Strictness: <L,U><L,1*U>,
     Unfolding: InlineRule (0, True, True)
                Emit.call1
                  `cast`
                (<LLVM.AST.Operand.Operand>_R
                 ->_R <[LLVM.AST.Operand.Operand]>_R
                 ->_R Trans
                          (Sym (Control.Monad.Trans.State.Lazy.N:StateT[0]
                                    <CodeGen.CodegenState>_N
                                    <Data.Functor.Identity.Identity>_R
                                    <LLVM.AST.Operand.Operand>_N))
                          (Sym (CodeGen.N:Codegen[0]) <LLVM.AST.Operand.Operand>_N)) -}
169292a120f46fe2d4d5ec551fd0ece0
  call1 ::
    LLVM.AST.Operand.Operand
    -> [LLVM.AST.Operand.Operand]
    -> CodeGen.CodegenState
    -> Data.Functor.Identity.Identity
         (LLVM.AST.Operand.Operand, CodeGen.CodegenState)
  {- Arity: 2, Strictness: <L,U><L,1*U>,
     Unfolding: (\ (fn :: LLVM.AST.Operand.Operand)
                   (args :: [LLVM.AST.Operand.Operand]) ->
                 let {
                   w :: Data.Either.Either
                          LLVM.AST.InlineAssembly.InlineAssembly LLVM.AST.Operand.Operand
                   = Data.Either.Right
                       @ LLVM.AST.InlineAssembly.InlineAssembly
                       @ LLVM.AST.Operand.Operand
                       fn
                 } in
                 let {
                   w1 :: [(LLVM.AST.Operand.Operand,
                           [LLVM.AST.ParameterAttribute.ParameterAttribute])]
                   = GHC.Base.map
                       @ LLVM.AST.Operand.Operand
                       @ (LLVM.AST.Operand.Operand,
                          [LLVM.AST.ParameterAttribute.ParameterAttribute])
                       Emit.call2
                       args
                 } in
                 let {
                   w2 :: LLVM.AST.Instruction.Instruction
                   = LLVM.AST.Instruction.Call
                       (GHC.Base.Nothing @ LLVM.AST.Instruction.TailCallKind)
                       LLVM.AST.CallingConvention.C
                       (GHC.Types.[] @ LLVM.AST.ParameterAttribute.ParameterAttribute)
                       w
                       w1
                       (GHC.Types.[]
                          @ (Data.Either.Either
                               LLVM.AST.FunctionAttribute.GroupID
                               LLVM.AST.FunctionAttribute.FunctionAttribute))
                       (GHC.Types.[] @ (GHC.Base.String, LLVM.AST.Operand.MetadataNode))
                 } in
                 \ (w3 :: CodeGen.CodegenState) ->
                 case CodeGen.$winstr w2 w3 of ww { (#,#) ww1 ww2 ->
                 (ww1, ww2)
                   `cast`
                 (Sym (Data.Functor.Identity.N:Identity[0]
                           <(LLVM.AST.Operand.Operand, CodeGen.CodegenState)>_R)) }) -}
412e9f032f76fcc844be5088c5bd4a14
  call2 ::
    LLVM.AST.Operand.Operand
    -> (LLVM.AST.Operand.Operand,
        [LLVM.AST.ParameterAttribute.ParameterAttribute])
  {- Arity: 1, HasNoCafRefs, Strictness: <L,U>m,
     Unfolding: InlineRule (1, True, False)
                (\ (x :: LLVM.AST.Operand.Operand) ->
                 (x,
                  GHC.Types.[] @ LLVM.AST.ParameterAttribute.ParameterAttribute)) -}
6b8e1cef78a54cc88cee941fd0197de6
  codegen ::
    LLVM.AST.Module -> [AST.Func] -> GHC.Types.IO LLVM.AST.Module
  {- Arity: 2, Strictness: <L,U><L,1*U>,
     Unfolding: (\ (mod :: LLVM.AST.Module) (fns :: [AST.Func]) ->
                 let {
                   newast :: LLVM.AST.Module
                   = case Emit.$wgo fns mod of ww { (#,#) ww1 ww2 -> ww2 }
                 } in
                 let {
                   lvl :: LLVM.Internal.Module.Module
                          -> GHC.Prim.State# GHC.Prim.RealWorld
                          -> (# GHC.Prim.State# GHC.Prim.RealWorld, LLVM.AST.Module #)
                     {- Arity: 2, Strictness: <S(S),1*U(U)><S,U>,
                        Unfolding: InlineRule (2, True, False)
                                   (\ (m :: LLVM.Internal.Module.Module)
                                      (eta :: GHC.Prim.State# GHC.Prim.RealWorld)[OneShot] ->
                                    case m `cast`
                                         (Trans
                                              (LLVM.Internal.Module.N:Module[0])
                                              (GHC.IORef.N:IORef[0] <GHC.Ptr.Ptr
                                                                       LLVM.Internal.FFI.Module.Module>_N)) of ww { GHC.STRef.STRef ww1 ->
                                    case LLVM.Internal.Module.$wmoduleLLVMAssembly
                                           ww1
                                           eta of ds1 { (#,#) ipv ipv1 ->
                                    case GHC.IO.Handle.Text.hPutStr2
                                           GHC.IO.Handle.FD.stdout
                                           ipv1
                                           GHC.Types.True
                                           ipv of ds2 { (#,#) ipv2 ipv3 ->
                                    (# ipv2, newast #) } } }) -}
                   = \ (m :: LLVM.Internal.Module.Module)
                       (eta :: GHC.Prim.State# GHC.Prim.RealWorld)[OneShot] ->
                     case m `cast`
                          (Trans
                               (LLVM.Internal.Module.N:Module[0])
                               (GHC.IORef.N:IORef[0] <GHC.Ptr.Ptr
                                                        LLVM.Internal.FFI.Module.Module>_N)) of ww { GHC.STRef.STRef ww1 ->
                     case LLVM.Internal.Module.$wmoduleLLVMAssembly
                            ww1
                            eta of ds1 { (#,#) ipv ipv1 ->
                     case GHC.IO.Handle.Text.hPutStr2
                            GHC.IO.Handle.FD.stdout
                            ipv1
                            GHC.Types.True
                            ipv of ds2 { (#,#) ipv2 ipv3 ->
                     (# ipv2, newast #) } } }
                 } in
                 LLVM.Internal.Context.withContext
                   @ LLVM.AST.Module
                   (\ (context :: LLVM.Internal.Context.Context)
                      (s :: GHC.Prim.State# GHC.Prim.RealWorld)[OneShot] ->
                    case context of ww { LLVM.Internal.Context.Context ww1 ->
                    case ww1 of ww2 { GHC.Ptr.Ptr ww3 ->
                    case newast of ww4 { LLVM.AST.Module ww5 ww6 ww7 ww8 ww9 ->
                    case LLVM.Internal.Module.$wwithModuleFromAST
                           @ LLVM.AST.Module
                           ww3
                           ww5
                           ww6
                           ww7
                           ww8
                           ww9
                           lvl
                             `cast`
                           (<LLVM.Internal.Module.Module>_R
                            ->_R Sym (GHC.Types.N:IO[0] <LLVM.AST.Module>_R))
                           s of ds1 { (#,#) ipv ipv1 ->
                    case ipv1 of wild {
                      Data.Either.Left x -> GHC.IO.failIO1 @ LLVM.AST.Module x ipv
                      Data.Either.Right y -> (# ipv, y #) } } } } })
                     `cast`
                   (<LLVM.Internal.Context.Context>_R
                    ->_R Sym (GHC.Types.N:IO[0] <LLVM.AST.Module>_R))) -}
c4d6da5c207b28aa132d8bf8a7b08c87
  codegenTop :: AST.Func -> CodeGen.LLVM ()
  {- Arity: 1, Strictness: <S,1*U(U,U,1*U,1*U)>, Inline: INLINE[0],
     Unfolding: InlineRule (1, True, False)
                (\ (w :: AST.Func) ->
                 case w of ww { AST.Func ww1 ww2 ww3 ww4 ->
                 Emit.$wcodegenTop ww1 ww2 ww3 ww4 }) -}
f112ff69267dc647445ccd41ac184c45
  codegenTop1 :: CodeGen.CodegenState
  {- Unfolding: (CodeGen.CodegenState
                   Emit.codegenTop7
                   Emit.codegenTop5
                   (GHC.Types.[] @ (GHC.Base.String, LLVM.AST.Operand.Operand))
                   Emit.codegenTop4
                   CodeGen.emptyCodegen1
                   Emit.codegenTop2) -}
6d1b68886f7d82d4c4a7f2c4d96adba6
  codegenTop2 :: CodeGen.Names
  {- Unfolding: (case Emit.codegenTop3 of wild { (,) qname supply ->
                 supply }) -}
c428b9d7230a2b1b1b9a12e9f413e538
  codegenTop3 :: (GHC.Base.String, CodeGen.Names)
  {- Unfolding: (case CodeGen.$wunikName
                        CodeGen.entryBlockName
                        (Data.Map.Base.Tip
                           @ GHC.Base.String
                           @ GHC.Types.Int) of ww { (#,#) ww1 ww2 ->
                 (ww1, ww2) }) -}
8f3216891945296d7fe464925199e02e
  codegenTop4 :: GHC.Types.Int
  {- HasNoCafRefs, Unfolding: (GHC.Types.I# 2#) -}
4bfe5ea0408d6d0ac24248bee5434bd5
  codegenTop5 ::
    Data.Map.Base.Map LLVM.AST.Name.Name CodeGen.BlockState
  {- Unfolding: (Emit.$sinsert_$sgo10
                   @ CodeGen.BlockState
                   Emit.codegenTop7
                   Emit.codegenTop6
                   (Data.Map.Base.Tip @ LLVM.AST.Name.Name @ CodeGen.BlockState)) -}
f2bd9b8814d561f36476c12f9957d2ed
  codegenTop6 :: CodeGen.BlockState
  {- HasNoCafRefs,
     Unfolding: (CodeGen.BlockState
                   CodeGen.emptyCodegen2
                   (GHC.Types.[]
                      @ (LLVM.AST.Instruction.Named LLVM.AST.Instruction.Instruction))
                   (GHC.Base.Nothing
                      @ (LLVM.AST.Instruction.Named LLVM.AST.Instruction.Terminator))) -}
33bbce31fece7515767e3c55041079d6
  codegenTop7 :: LLVM.AST.Name.Name
  {- Unfolding: (LLVM.AST.Name.Name Emit.codegenTop_qname) -}
d7beeea7d57169504655a17cb450a843
  codegenTop8 :: CodeGen.Codegen LLVM.AST.Operand.Operand
  {- Strictness: x -}
bb6551a5dbb521288e953e593069dcef
  codegenTop_qname :: GHC.Base.String
  {- Unfolding: (case Emit.codegenTop3 of wild { (,) qname supply ->
                 qname }) -}
9769b16d6883ad369d9b3c0c9f0c238e
  declarationGen :: AST.Declaration -> CodeGen.LLVM ()
  {- Arity: 1, Strictness: <S,1*U>,
     Unfolding: (\ (c :: AST.Declaration) ->
                 case c of wild {
                   AST.ExternDecl ds ds1 ds2
                   -> let {
                        def :: LLVM.AST.Type.Type
                        = case ds2 of wild1 {
                            AST.IntC -> CodeGen.intL AST.StringC -> CodeGen.getArgList2 }
                      } in
                      let {
                        def1 :: LLVM.AST.Name.Name = LLVM.AST.Name.Name ds
                      } in
                      let {
                        def2 :: [LLVM.AST.Global.Parameter] = CodeGen.getDef_go ds1
                      } in
                      let {
                        def3 :: ([LLVM.AST.Global.Parameter], GHC.Types.Bool)
                          {- Strictness: m -}
                        = (def2, GHC.Types.False)
                      } in
                      let {
                        def4 :: LLVM.AST.Global.Global
                        = LLVM.AST.Global.Function
                            LLVM.AST.Linkage.External
                            LLVM.AST.Visibility.Default
                            (GHC.Base.Nothing @ LLVM.AST.DLL.StorageClass)
                            LLVM.AST.CallingConvention.C
                            (GHC.Types.[] @ LLVM.AST.ParameterAttribute.ParameterAttribute)
                            def
                            def1
                            def3
                            (GHC.Types.[]
                               @ (Data.Either.Either
                                    LLVM.AST.FunctionAttribute.GroupID
                                    LLVM.AST.FunctionAttribute.FunctionAttribute))
                            (GHC.Base.Nothing @ GHC.Base.String)
                            (GHC.Base.Nothing @ GHC.Base.String)
                            LLVM.AST.Global.functionDefaults1
                            (GHC.Base.Nothing @ GHC.Base.String)
                            (GHC.Base.Nothing @ LLVM.AST.Constant.Constant)
                            (GHC.Types.[] @ LLVM.AST.Global.BasicBlock)
                            (GHC.Base.Nothing @ LLVM.AST.Constant.Constant)
                      } in
                      let {
                        def5 :: LLVM.AST.Definition = LLVM.AST.GlobalDefinition def4
                      } in
                      (\ (eta :: LLVM.AST.Module) ->
                       (GHC.Tuple.(),
                        case eta of wild1 { LLVM.AST.Module ds3 ds4 ds5 ds6 ds7 ->
                        LLVM.AST.Module
                          ds3
                          ds4
                          ds5
                          ds6
                          (GHC.Types.: @ LLVM.AST.Definition def5 ds7) }))
                        `cast`
                      (Trans
                           (<LLVM.AST.Module>_R
                            ->_R Sym (Data.Functor.Identity.N:Identity[0]
                                          <((), LLVM.AST.Module)>_R))
                           (Trans
                                (Sym (Control.Monad.Trans.State.Lazy.N:StateT[0]
                                          <LLVM.AST.Module>_N
                                          <Data.Functor.Identity.Identity>_R
                                          <()>_N))
                                (Sym (CodeGen.N:LLVM[0]) <()>_N)))
                   AST.VarDecl ipv ipv1 -> Emit.declarationGen1 }) -}
c59af9adeb61b7d47e793a47e055c16c
  declarationGen1 :: CodeGen.LLVM ()
  {- Strictness: x -}
992c5f68b2a7a614d533c17efaf2e124
  exprGen :: AST.Expr -> CodeGen.Codegen LLVM.AST.Operand.Operand
  {- Arity: 1, Strictness: <S,1*U>,
     Unfolding: InlineRule (1, True, False)
                (\ (ds :: AST.Expr) ->
                 case ds of wild {
                   DEFAULT -> Emit.exprGen4
                   AST.FuncCallStmt f -> Emit.funcCallGen f
                   AST.LiteralStmt st
                   -> (Emit.exprGen1 st)
                        `cast`
                      (Trans
                           (Sym (Control.Monad.Trans.State.Lazy.N:StateT[0]
                                     <CodeGen.CodegenState>_N
                                     <Data.Functor.Identity.Identity>_R
                                     <LLVM.AST.Operand.Operand>_N))
                           (Sym (CodeGen.N:Codegen[0]) <LLVM.AST.Operand.Operand>_N)) }) -}
d5d1f14786a15dbc930ea583ecf95067
  exprGen1 ::
    AST.Literal
    -> CodeGen.CodegenState
    -> Data.Functor.Identity.Identity
         (LLVM.AST.Operand.Operand, CodeGen.CodegenState)
  {- Arity: 2, Strictness: <S,1*U><L,U>m,
     Unfolding: InlineRule (2, True, False)
                (\ (ds :: AST.Literal) (eta :: CodeGen.CodegenState) ->
                 case ds of wild {
                   AST.StrLiteral ipv
                   -> case Emit.exprGen3
                      ret_ty (Data.Functor.Identity.Identity
                                (LLVM.AST.Operand.Operand, CodeGen.CodegenState))
                      of {}
                   AST.IntLiteral n
                   -> (LLVM.AST.Operand.ConstantOperand
                         (LLVM.AST.Constant.Int Emit.exprGen2 n),
                       eta)
                        `cast`
                      (Sym (Data.Functor.Identity.N:Identity[0]
                                <(LLVM.AST.Operand.Operand, CodeGen.CodegenState)>_R)) }) -}
bbbb5b1be07097dbf60749a7569292a6
  exprGen2 :: GHC.Word.Word32
  {- HasNoCafRefs, Strictness: m, Unfolding: (GHC.Word.W32# 32##) -}
6ec76ee85e5e299f46e7236f23345fe2
  exprGen3 :: CodeGen.Codegen LLVM.AST.Operand.Operand
  {- Strictness: x -}
6b2210c03770bb3195ecdfaa7c1007c1
  exprGen4 :: CodeGen.Codegen LLVM.AST.Operand.Operand
  {- Strictness: x -}
f95f39a490f9b9dfc09977f0209c9c59
  externf :: LLVM.AST.Name.Name -> LLVM.AST.Operand.Operand
  {- Arity: 1, HasNoCafRefs, Strictness: <L,U>m2,
     Unfolding: InlineRule (1, True, False)
                (\ (x :: LLVM.AST.Name.Name) ->
                 LLVM.AST.Operand.ConstantOperand
                   (LLVM.AST.Constant.GlobalReference CodeGen.intL x)) -}
c4b4d1c26e34464733cee7c18b1bd76a
  fadd ::
    LLVM.AST.Operand.Operand
    -> LLVM.AST.Operand.Operand
    -> CodeGen.Codegen LLVM.AST.Operand.Operand
  {- Arity: 3, Strictness: <L,U><L,U><L,U(U,U,U,U,U(U),U)>m,
     Unfolding: InlineRule (0, True, True)
                Emit.binops12
                  `cast`
                (<LLVM.AST.Operand.Operand>_R
                 ->_R <LLVM.AST.Operand.Operand>_R
                 ->_R Trans
                          (Sym (Control.Monad.Trans.State.Lazy.N:StateT[0]
                                    <CodeGen.CodegenState>_N
                                    <Data.Functor.Identity.Identity>_R
                                    <LLVM.AST.Operand.Operand>_N))
                          (Sym (CodeGen.N:Codegen[0]) <LLVM.AST.Operand.Operand>_N)) -}
682b9712fd3b6a3dcc4b97b36385a696
  fdiv ::
    LLVM.AST.Operand.Operand
    -> LLVM.AST.Operand.Operand
    -> CodeGen.Codegen LLVM.AST.Operand.Operand
  {- Arity: 3, Strictness: <L,U><L,U><L,U(U,U,U,U,U(U),U)>m,
     Unfolding: InlineRule (0, True, True)
                Emit.binops6
                  `cast`
                (<LLVM.AST.Operand.Operand>_R
                 ->_R <LLVM.AST.Operand.Operand>_R
                 ->_R Trans
                          (Sym (Control.Monad.Trans.State.Lazy.N:StateT[0]
                                    <CodeGen.CodegenState>_N
                                    <Data.Functor.Identity.Identity>_R
                                    <LLVM.AST.Operand.Operand>_N))
                          (Sym (CodeGen.N:Codegen[0]) <LLVM.AST.Operand.Operand>_N)) -}
4df1ae5fc9c89932b55b612804ee42cd
  fmul ::
    LLVM.AST.Operand.Operand
    -> LLVM.AST.Operand.Operand
    -> CodeGen.Codegen LLVM.AST.Operand.Operand
  {- Arity: 3, Strictness: <L,U><L,U><L,U(U,U,U,U,U(U),U)>m,
     Unfolding: InlineRule (0, True, True)
                Emit.binops8
                  `cast`
                (<LLVM.AST.Operand.Operand>_R
                 ->_R <LLVM.AST.Operand.Operand>_R
                 ->_R Trans
                          (Sym (Control.Monad.Trans.State.Lazy.N:StateT[0]
                                    <CodeGen.CodegenState>_N
                                    <Data.Functor.Identity.Identity>_R
                                    <LLVM.AST.Operand.Operand>_N))
                          (Sym (CodeGen.N:Codegen[0]) <LLVM.AST.Operand.Operand>_N)) -}
cd2c0bfa5da00ca506d87fb96afbc5a4
  fsub ::
    LLVM.AST.Operand.Operand
    -> LLVM.AST.Operand.Operand
    -> CodeGen.Codegen LLVM.AST.Operand.Operand
  {- Arity: 3, Strictness: <L,U><L,U><L,U(U,U,U,U,U(U),U)>m,
     Unfolding: InlineRule (0, True, True)
                Emit.binops10
                  `cast`
                (<LLVM.AST.Operand.Operand>_R
                 ->_R <LLVM.AST.Operand.Operand>_R
                 ->_R Trans
                          (Sym (Control.Monad.Trans.State.Lazy.N:StateT[0]
                                    <CodeGen.CodegenState>_N
                                    <Data.Functor.Identity.Identity>_R
                                    <LLVM.AST.Operand.Operand>_N))
                          (Sym (CodeGen.N:Codegen[0]) <LLVM.AST.Operand.Operand>_N)) -}
75c1de36048449207d9cb125430e61bb
  funcCallGen ::
    AST.FuncCall -> CodeGen.Codegen LLVM.AST.Operand.Operand
  {- Arity: 1, Strictness: <S,1*U(U,1*U)>, Inline: INLINE[0],
     Unfolding: InlineRule (1, True, False)
                (\ (w :: AST.FuncCall) ->
                 case w of ww { AST.FuncCall ww1 ww2 ->
                 Emit.$wfuncCallGen ww1 ww2 }) -}
cba289eb0fddfb1994a0101c7291077d
  funcCallGen_go ::
    [AST.Expr] -> CodeGen.Codegen [LLVM.AST.Operand.Operand]
  {- Arity: 1, Strictness: <S,1*U> -}
419ec7665083a5816d4b0366bcc7e4fc
  funcGen :: AST.Func -> CodeGen.LLVM ()
  {- Arity: 1, Strictness: <L,1*U(U,1*U,1*U,A)>,
     Unfolding: (\ (x :: AST.Func) ->
                 let {
                   def :: LLVM.AST.Definition
                   = case x of ww { AST.Func ww1 ww2 ww3 ww4 ->
                     LLVM.AST.GlobalDefinition
                       (LLVM.AST.Global.Function
                          LLVM.AST.Linkage.External
                          LLVM.AST.Visibility.Default
                          (GHC.Base.Nothing @ LLVM.AST.DLL.StorageClass)
                          LLVM.AST.CallingConvention.C
                          (GHC.Types.[] @ LLVM.AST.ParameterAttribute.ParameterAttribute)
                          (case ww3 of wild {
                             AST.IntC -> CodeGen.intL AST.StringC -> CodeGen.getArgList2 })
                          (LLVM.AST.Name.Name ww1)
                          (CodeGen.getDef_go ww2, GHC.Types.False)
                          (GHC.Types.[]
                             @ (Data.Either.Either
                                  LLVM.AST.FunctionAttribute.GroupID
                                  LLVM.AST.FunctionAttribute.FunctionAttribute))
                          (GHC.Base.Nothing @ GHC.Base.String)
                          (GHC.Base.Nothing @ GHC.Base.String)
                          LLVM.AST.Global.functionDefaults1
                          (GHC.Base.Nothing @ GHC.Base.String)
                          (GHC.Base.Nothing @ LLVM.AST.Constant.Constant)
                          (GHC.Types.[] @ LLVM.AST.Global.BasicBlock)
                          (GHC.Base.Nothing @ LLVM.AST.Constant.Constant)) }
                 } in
                 (\ (eta :: LLVM.AST.Module) ->
                  (GHC.Tuple.(),
                   case eta of wild { LLVM.AST.Module ds ds1 ds2 ds3 ds4 ->
                   LLVM.AST.Module
                     ds
                     ds1
                     ds2
                     ds3
                     (GHC.Types.: @ LLVM.AST.Definition def ds4) }))
                   `cast`
                 (Trans
                      (<LLVM.AST.Module>_R
                       ->_R Sym (Data.Functor.Identity.N:Identity[0]
                                     <((), LLVM.AST.Module)>_R))
                      (Trans
                           (Sym (Control.Monad.Trans.State.Lazy.N:StateT[0]
                                     <LLVM.AST.Module>_N <Data.Functor.Identity.Identity>_R <()>_N))
                           (Sym (CodeGen.N:LLVM[0]) <()>_N)))) -}
ad0a760cbd41fe6e2cc8005d5de3f74b
  liftError ::
    Control.Monad.Trans.Except.ExceptT GHC.Base.String GHC.Types.IO a
    -> GHC.Types.IO a
  {- Arity: 2, Strictness: <C(S(SS)),1*C1(U(U,1*U))><S,U>,
     Unfolding: InlineRule (0, True, True)
                Emit.liftError1
                  `cast`
                (forall (a :: <*>_N).
                 <Control.Monad.Trans.Except.ExceptT
                    GHC.Base.String GHC.Types.IO a>_R
                 ->_R Sym (GHC.Types.N:IO[0] <a>_R)) -}
d057a72d4a688a9a592329abb910e1a1
  liftError1 ::
    Control.Monad.Trans.Except.ExceptT GHC.Base.String GHC.Types.IO a
    -> GHC.Prim.State# GHC.Prim.RealWorld
    -> (# GHC.Prim.State# GHC.Prim.RealWorld, a #)
  {- Arity: 2, Strictness: <C(S(SS)),1*C1(U(U,1*U))><S,U>,
     Unfolding: InlineRule (2, True, False)
                (\ @ a
                   (x :: Control.Monad.Trans.Except.ExceptT
                           GHC.Base.String GHC.Types.IO a)
                   (s :: GHC.Prim.State# GHC.Prim.RealWorld)[OneShot] ->
                 case x `cast`
                      (Trans
                           (Control.Monad.Trans.Except.N:ExceptT[0]
                                <GHC.Base.String>_N <GHC.Types.IO>_R <a>_N)
                           (GHC.Types.N:IO[0] <Data.Either.Either GHC.Base.String a>_R))
                        s of ds1 { (#,#) ipv ipv1 ->
                 case ipv1 of wild {
                   Data.Either.Left x1 -> GHC.IO.failIO1 @ a x1 ipv
                   Data.Either.Right y -> (# ipv, y #) } }) -}
9cbffb93e5f7a20f3fc441d2d6d29609
  literalGen ::
    AST.Literal -> CodeGen.Codegen LLVM.AST.Operand.Operand
  {- Arity: 2, Strictness: <S,1*U><L,U>m,
     Unfolding: InlineRule (0, True, True)
                Emit.exprGen1
                  `cast`
                (<AST.Literal>_R
                 ->_R Trans
                          (Sym (Control.Monad.Trans.State.Lazy.N:StateT[0]
                                    <CodeGen.CodegenState>_N
                                    <Data.Functor.Identity.Identity>_R
                                    <LLVM.AST.Operand.Operand>_N))
                          (Sym (CodeGen.N:Codegen[0]) <LLVM.AST.Operand.Operand>_N)) -}
5f92a296e2b32636a09e416015e12f56
  toArgs ::
    [LLVM.AST.Operand.Operand]
    -> [(LLVM.AST.Operand.Operand,
         [LLVM.AST.ParameterAttribute.ParameterAttribute])]
  {- Arity: 1, HasNoCafRefs,
     Unfolding: (GHC.Base.map
                   @ LLVM.AST.Operand.Operand
                   @ (LLVM.AST.Operand.Operand,
                      [LLVM.AST.ParameterAttribute.ParameterAttribute])
                   Emit.call2) -}
a6aac55e35d52c3358b8806007da247d
  varDeclGen :: (AST.Type, AST.Name) -> CodeGen.Codegen ()
  {- Arity: 2, Strictness: <L,U(1*U,U)><L,U(U,U,U,U,U(U),U)>m,
     Unfolding: InlineRule (0, True, True)
                Emit.varDeclGen1
                  `cast`
                (<(AST.Type, AST.Name)>_R
                 ->_R Trans
                          (<CodeGen.CodegenState>_R
                           ->_R Sym (Data.Functor.Identity.N:Identity[0]
                                         <((), CodeGen.CodegenState)>_R))
                          (Trans
                               (Sym (Control.Monad.Trans.State.Lazy.N:StateT[0]
                                         <CodeGen.CodegenState>_N
                                         <Data.Functor.Identity.Identity>_R
                                         <()>_N))
                               (Sym (CodeGen.N:Codegen[0]) <()>_N))) -}
f50a16d0ec9265da65c3ff16ff54e8d7
  varDeclGen1 ::
    (AST.Type, AST.Name)
    -> CodeGen.CodegenState -> ((), CodeGen.CodegenState)
  {- Arity: 2, Strictness: <L,U(1*U,U)><L,U(U,U,U,U,U(U),U)>m,
     Inline: INLINE[0],
     Unfolding: InlineRule (2, True, False)
                (\ (w :: (AST.Type, AST.Name)) (w1 :: CodeGen.CodegenState) ->
                 case Emit.$wvarDeclGen w w1 of ww { (#,#) ww1 ww2 ->
                 (ww1, ww2) }) -}
6961b3e006bf260c5260eb92898b9e2d
  varGen :: AST.Expr -> CodeGen.Codegen LLVM.AST.Operand.Operand
  {- Arity: 2, Strictness: <S,1*U><L,1*U(U,U,U,U,U,U)>m,
     Unfolding: InlineRule (0, True, True)
                Emit.varGen1
                  `cast`
                (<AST.Expr>_R
                 ->_R Trans
                          (Sym (Control.Monad.Trans.State.Lazy.N:StateT[0]
                                    <CodeGen.CodegenState>_N
                                    <Data.Functor.Identity.Identity>_R
                                    <LLVM.AST.Operand.Operand>_N))
                          (Sym (CodeGen.N:Codegen[0]) <LLVM.AST.Operand.Operand>_N)) -}
35a92971c645cea807297444260eb904
  varGen1 ::
    AST.Expr
    -> CodeGen.CodegenState
    -> Data.Functor.Identity.Identity
         (LLVM.AST.Operand.Operand, CodeGen.CodegenState)
  {- Arity: 2, Strictness: <S,1*U><L,1*U(U,U,U,U,U,U)>m,
     Inline: INLINE[0],
     Unfolding: InlineRule (2, True, False)
                (\ (w :: AST.Expr) (w1 :: CodeGen.CodegenState) ->
                 case Emit.$wvarGen w w1 of ww { (#,#) ww1 ww2 ->
                 (ww1, ww2)
                   `cast`
                 (Sym (Data.Functor.Identity.N:Identity[0]
                           <(LLVM.AST.Operand.Operand, CodeGen.CodegenState)>_R)) }) -}
"SPEC/Emit fromList @ Op _" [ALWAYS] forall @ a
                                            ($dOrd :: GHC.Classes.Ord AST.Op)
  Data.Map.Base.fromList @ AST.Op @ a $dOrd = Emit.$sfromList @ a
vectorised variables:
vectorised tycons:
vectorised reused tycons:
parallel variables:
parallel tycons:
trusted: none
require own pkg trusted: False

